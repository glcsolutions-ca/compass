name: Cloud Deployment Pipeline Replay

on:
  workflow_dispatch:
    inputs:
      release_candidate_sha:
        description: Release candidate SHA to replay
        required: true
        type: string

permissions:
  actions: read
  contents: read
  deployments: write
  id-token: write
  pull-requests: read

jobs:
  resolve_replay_source:
    name: resolve-replay-source
    runs-on: ubuntu-latest
    outputs:
      release_candidate_sha: ${{ steps.source.outputs.release_candidate_sha }}
      source_run_id: ${{ steps.resolve_run.outputs.run_id }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: Resolve release candidate SHA
        id: source
        env:
          RELEASE_CANDIDATE_SHA: ${{ inputs.release_candidate_sha }}
        run: |
          set -euo pipefail
          if [ -z "${RELEASE_CANDIDATE_SHA:-}" ]; then
            echo "release_candidate_sha input is required" >&2
            exit 1
          fi
          echo "release_candidate_sha=$RELEASE_CANDIDATE_SHA" >> "$GITHUB_OUTPUT"

      - name: Resolve source run id
        id: resolve_run
        env:
          GITHUB_TOKEN: ${{ github.token }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          WORKFLOW_FILE: cloud-deployment-pipeline.yml
          HEAD_SHA: ${{ steps.source.outputs.release_candidate_sha }}
          RUN_EVENT: push
          RUN_STATUS: success
          RUN_STATUS_FALLBACK: completed
        run: node scripts/pipeline/shared/resolve-triggered-run-id.mjs

  load_release_candidate:
    name: load-release-candidate
    needs:
      - resolve_replay_source
    runs-on: ubuntu-latest
    outputs:
      head_sha: ${{ steps.parse.outputs.head_sha }}
      api_ref: ${{ steps.parse.outputs.api_ref }}
      web_ref: ${{ steps.parse.outputs.web_ref }}
      worker_ref: ${{ steps.parse.outputs.worker_ref }}
      dynamic_sessions_runtime_ref: ${{ steps.parse.outputs.dynamic_sessions_runtime_ref }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download release candidate artifact
        uses: actions/download-artifact@v4
        with:
          name: release-candidate-${{ needs.resolve_replay_source.outputs.release_candidate_sha }}
          path: .artifacts/release-candidate/${{ needs.resolve_replay_source.outputs.release_candidate_sha }}
          run-id: ${{ needs.resolve_replay_source.outputs.source_run_id }}
          github-token: ${{ github.token }}

      - name: Parse release candidate manifest
        id: parse
        run: |
          set -euo pipefail

          manifest_path=".artifacts/release-candidate/${{ needs.resolve_replay_source.outputs.release_candidate_sha }}/manifest.json"
          head_sha="$(jq -r '.headSha' "$manifest_path")"
          api_ref="$(jq -r '.releaseCandidate.apiRef' "$manifest_path")"
          web_ref="$(jq -r '.releaseCandidate.webRef' "$manifest_path")"
          worker_ref="$(jq -r '.releaseCandidate.workerRef' "$manifest_path")"
          dynamic_sessions_runtime_ref="$(jq -r '.releaseCandidate.dynamicSessionsRuntimeRef' "$manifest_path")"

          for image in "$api_ref" "$web_ref" "$worker_ref" "$dynamic_sessions_runtime_ref"; do
            if [[ "$image" != *"@sha256:"* ]]; then
              echo "Release candidate image is not digest-pinned: $image" >&2
              exit 1
            fi
          done

          echo "head_sha=$head_sha" >> "$GITHUB_OUTPUT"
          echo "api_ref=$api_ref" >> "$GITHUB_OUTPUT"
          echo "web_ref=$web_ref" >> "$GITHUB_OUTPUT"
          echo "worker_ref=$worker_ref" >> "$GITHUB_OUTPUT"
          echo "dynamic_sessions_runtime_ref=$dynamic_sessions_runtime_ref" >> "$GITHUB_OUTPUT"

      - name: Upload replay manifest copy
        uses: actions/upload-artifact@v4
        with:
          name: replay-release-candidate-${{ steps.parse.outputs.head_sha }}
          path: .artifacts/release-candidate/${{ needs.resolve_replay_source.outputs.release_candidate_sha }}/manifest.json
          if-no-files-found: error

  deploy_cloud:
    name: deploy-cloud
    needs:
      - load_release_candidate
    runs-on: ubuntu-latest
    timeout-minutes: 90
    environment: production
    concurrency:
      group: production-cloud-mutation
      cancel-in-progress: false
    outputs:
      head_sha: ${{ steps.set_head.outputs.head_sha }}
      api_prod_url: ${{ steps.resolve_urls.outputs.api_prod_url }}
      web_prod_url: ${{ steps.resolve_urls.outputs.web_prod_url }}
    env:
      HEAD_SHA: ${{ needs.load_release_candidate.outputs.head_sha }}
      API_IMAGE: ${{ needs.load_release_candidate.outputs.api_ref }}
      WEB_IMAGE: ${{ needs.load_release_candidate.outputs.web_ref }}
      WORKER_IMAGE: ${{ needs.load_release_candidate.outputs.worker_ref }}
      DYNAMIC_SESSIONS_RUNTIME_IMAGE: ${{ needs.load_release_candidate.outputs.dynamic_sessions_runtime_ref }}
      AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}
      AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
      AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
      KEY_VAULT_NAME: ${{ vars.KEY_VAULT_NAME }}
      TFSTATE_RESOURCE_GROUP: ${{ vars.TFSTATE_RESOURCE_GROUP }}
      TFSTATE_STORAGE_ACCOUNT: ${{ vars.TFSTATE_STORAGE_ACCOUNT }}
      TFSTATE_CONTAINER: ${{ vars.TFSTATE_CONTAINER }}
      TFSTATE_KEY: ${{ vars.TFSTATE_KEY }}
      API_IDENTIFIER_URI: ${{ vars.API_IDENTIFIER_URI }}
      IDENTITY_OWNER_OBJECT_IDS_JSON: ${{ vars.IDENTITY_OWNER_OBJECT_IDS_JSON }}
      ACA_WEB_CUSTOM_DOMAIN: ${{ vars.ACA_WEB_CUSTOM_DOMAIN }}
      IDENTITY_CONVERGE_ENABLED: ${{ vars.IDENTITY_CONVERGE_ENABLED || 'false' }}
      MIGRATION_TIMEOUT_SECONDS: ${{ vars.MIGRATION_TIMEOUT_SECONDS || '900' }}
      MIGRATION_CONTAINER_NAME: ${{ vars.MIGRATION_CONTAINER_NAME || 'migrate' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set head SHA output
        id: set_head
        run: echo "head_sha=$HEAD_SHA" >> "$GITHUB_OUTPUT"

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: Validate release candidate refs
        run: |
          set -euo pipefail
          for image in "$API_IMAGE" "$WEB_IMAGE" "$WORKER_IMAGE" "$DYNAMIC_SESSIONS_RUNTIME_IMAGE"; do
            if [ -z "$image" ]; then
              echo "Missing release candidate image reference" >&2
              exit 1
            fi
            if [[ "$image" != *"@sha256:"* ]]; then
              echo "Release candidate image is not digest-pinned: $image" >&2
              exit 1
            fi
          done

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_GITHUB_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Validate Key Vault secret contract
        run: node scripts/pipeline/cloud/deployment-stage/validate-keyvault-secrets.mjs

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Converge identity (optional)
        env:
          ARM_USE_OIDC: "true"
          ARM_USE_AZUREAD: "true"
          ARM_CLIENT_ID: ${{ vars.AZURE_GITHUB_CLIENT_ID }}
          ARM_TENANT_ID: ${{ env.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ env.AZURE_SUBSCRIPTION_ID }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail

          if [ "${IDENTITY_CONVERGE_ENABLED,,}" != "true" ]; then
            echo "Identity converge is disabled; skipping."
            exit 0
          fi

          if [ -z "${TFSTATE_RESOURCE_GROUP:-}" ] || [ -z "${TFSTATE_STORAGE_ACCOUNT:-}" ] || [ -z "${TFSTATE_CONTAINER:-}" ] || [ -z "${TFSTATE_KEY:-}" ] || [ -z "${API_IDENTIFIER_URI:-}" ] || [ -z "${IDENTITY_OWNER_OBJECT_IDS_JSON:-}" ] || [ -z "${ACA_WEB_CUSTOM_DOMAIN:-}" ]; then
            echo "Identity converge is not configured in repository variables; skipping."
            exit 0
          fi

          gh_organization="${GITHUB_REPOSITORY%%/*}"
          gh_repository="${GITHUB_REPOSITORY##*/}"

          terraform -chdir=infra/identity init \
            -input=false \
            -backend-config="resource_group_name=${TFSTATE_RESOURCE_GROUP}" \
            -backend-config="storage_account_name=${TFSTATE_STORAGE_ACCOUNT}" \
            -backend-config="container_name=${TFSTATE_CONTAINER}" \
            -backend-config="key=${TFSTATE_KEY}" \
            -backend-config="use_oidc=true" \
            -backend-config="use_azuread_auth=true" \
            -backend-config="tenant_id=${ARM_TENANT_ID}" \
            -backend-config="subscription_id=${ARM_SUBSCRIPTION_ID}" \
            -backend-config="client_id=${ARM_CLIENT_ID}"

          terraform -chdir=infra/identity apply \
            -input=false \
            -auto-approve \
            -var-file=env/prod.tfvars \
            -var "github_organization=${gh_organization}" \
            -var "github_repository=${gh_repository}" \
            -var "github_environment_name=production" \
            -var "api_identifier_uri=${API_IDENTIFIER_URI}" \
            -var "owners=${IDENTITY_OWNER_OBJECT_IDS_JSON}" \
            -var "web_custom_domain=${ACA_WEB_CUSTOM_DOMAIN}"

          mkdir -p ".artifacts/identity/$HEAD_SHA"
          terraform -chdir=infra/identity output -json > ".artifacts/identity/$HEAD_SHA/outputs.json"

      - name: Apply infra
        run: |
          set -euo pipefail

          export ARM_TEMPLATE_FILE="infra/azure/main.bicep"
          export ARM_PARAMETERS_FILE="infra/azure/environments/cloud.bicepparam"
          export ARM_ARTIFACT_DIR=".artifacts/infra/$HEAD_SHA"
          export ARM_DEPLOYMENT_NAME_PREFIX="replay"
          export ARM_PARAMETERS_OVERRIDES="$(cat <<PARAMS
          apiImage=$API_IMAGE
          webImage=$WEB_IMAGE
          workerImage=$WORKER_IMAGE
          dynamicSessionsRuntimeImage=$DYNAMIC_SESSIONS_RUNTIME_IMAGE
          PARAMS
          )"

          node scripts/pipeline/cloud/deployment-stage/apply-infra.mjs

      - name: Resolve deployed resource names
        run: |
          set -euo pipefail

          deployment_json=".artifacts/infra/$HEAD_SHA/deployment.json"

          echo "ACA_API_APP_NAME=$(jq -er '.properties.outputs.apiContainerAppName.value' "$deployment_json")" >> "$GITHUB_ENV"
          echo "ACA_WEB_APP_NAME=$(jq -er '.properties.outputs.webContainerAppName.value' "$deployment_json")" >> "$GITHUB_ENV"
          echo "ACA_WORKER_APP_NAME=$(jq -er '.properties.outputs.workerContainerAppName.value' "$deployment_json")" >> "$GITHUB_ENV"
          echo "DYNAMIC_SESSIONS_POOL_NAME=$(jq -er '.properties.outputs.dynamicSessionsPoolNameOutput.value' "$deployment_json")" >> "$GITHUB_ENV"
          echo "DYNAMIC_SESSIONS_EXECUTOR_IDENTITY_NAME=$(jq -er '.properties.outputs.dynamicSessionsExecutorIdentityName.value' "$deployment_json")" >> "$GITHUB_ENV"
          echo "ACA_MIGRATE_JOB_NAME=$(jq -er '.properties.outputs.migrationJobName.value' "$deployment_json")" >> "$GITHUB_ENV"
          echo "SERVICE_BUS_PROD_NAMESPACE_NAME=$(jq -er '.properties.outputs.serviceBusProdNamespaceNameOutput.value' "$deployment_json")" >> "$GITHUB_ENV"
          echo "SERVICE_BUS_QUEUE_NAME=$(jq -er '.properties.outputs.serviceBusQueueNameOutput.value' "$deployment_json")" >> "$GITHUB_ENV"
          echo "WORKER_RUNTIME_IDENTITY_CLIENT_ID=$(jq -er '.properties.outputs.workerRuntimeIdentityClientId.value' "$deployment_json")" >> "$GITHUB_ENV"
          echo "WORKER_RUNTIME_IDENTITY_PRINCIPAL_ID=$(jq -er '.properties.outputs.workerRuntimeIdentityPrincipalId.value' "$deployment_json")" >> "$GITHUB_ENV"

      - name: Verify Dynamic Sessions convergence
        env:
          RELEASE_CANDIDATE_DYNAMIC_SESSIONS_RUNTIME_REF: ${{ env.DYNAMIC_SESSIONS_RUNTIME_IMAGE }}
        run: node scripts/pipeline/cloud/deployment-stage/verify-dynamic-sessions-convergence.mjs

      - name: Verify worker Service Bus cutover
        run: node scripts/pipeline/cloud/deployment-stage/verify-worker-servicebus-cutover.mjs

      - name: Update migration job image
        run: |
          az containerapp job update \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$ACA_MIGRATE_JOB_NAME" \
            --image "$API_IMAGE" \
            --output none

      - name: Run migration job
        id: migration_start
        env:
          AZURE_RESOURCE_GROUP: ${{ env.AZURE_RESOURCE_GROUP }}
          ACA_MIGRATE_JOB_NAME: ${{ env.ACA_MIGRATE_JOB_NAME }}
        run: node scripts/pipeline/cloud/deployment-stage/start-migration-job.mjs

      - name: Wait for migration completion
        env:
          AZURE_RESOURCE_GROUP: ${{ env.AZURE_RESOURCE_GROUP }}
          ACA_MIGRATE_JOB_NAME: ${{ env.ACA_MIGRATE_JOB_NAME }}
          MIGRATION_EXECUTION_NAME: ${{ steps.migration_start.outputs.migration_execution_name }}
          MIGRATION_TIMEOUT_SECONDS: ${{ env.MIGRATION_TIMEOUT_SECONDS }}
          MIGRATION_CONTAINER_NAME: ${{ env.MIGRATION_CONTAINER_NAME }}
        run: node scripts/pipeline/cloud/deployment-stage/wait-migration-job.mjs

      - name: Deploy API
        uses: azure/container-apps-deploy-action@v1
        with:
          imageToDeploy: ${{ env.API_IMAGE }}
          containerAppName: ${{ env.ACA_API_APP_NAME }}
          resourceGroup: ${{ env.AZURE_RESOURCE_GROUP }}
          disableTelemetry: true

      - name: Deploy Web
        uses: azure/container-apps-deploy-action@v1
        with:
          imageToDeploy: ${{ env.WEB_IMAGE }}
          containerAppName: ${{ env.ACA_WEB_APP_NAME }}
          resourceGroup: ${{ env.AZURE_RESOURCE_GROUP }}
          disableTelemetry: true

      - name: Deploy Worker
        uses: azure/container-apps-deploy-action@v1
        with:
          imageToDeploy: ${{ env.WORKER_IMAGE }}
          containerAppName: ${{ env.ACA_WORKER_APP_NAME }}
          resourceGroup: ${{ env.AZURE_RESOURCE_GROUP }}
          disableTelemetry: true

      - name: Resolve production URLs
        id: resolve_urls
        run: |
          set -euo pipefail

          api_prod_url="https://$(az containerapp show --resource-group "$AZURE_RESOURCE_GROUP" --name "$ACA_API_APP_NAME" --query 'properties.configuration.ingress.fqdn' --output tsv)"
          web_prod_url="https://$(az containerapp show --resource-group "$AZURE_RESOURCE_GROUP" --name "$ACA_WEB_APP_NAME" --query 'properties.configuration.ingress.fqdn' --output tsv)"

          echo "api_prod_url=$api_prod_url" >> "$GITHUB_OUTPUT"
          echo "web_prod_url=$web_prod_url" >> "$GITHUB_OUTPUT"

      - name: Upload deployment artifacts
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: replay-deploy-cloud-${{ env.HEAD_SHA }}
          path: |
            .artifacts/infra/${{ env.HEAD_SHA }}
            .artifacts/identity/${{ env.HEAD_SHA }}
            .artifacts/deploy/${{ env.HEAD_SHA }}
          if-no-files-found: warn

  production_smoke:
    name: production-smoke
    needs:
      - deploy_cloud
    runs-on: ubuntu-latest
    timeout-minutes: 20
    environment: production
    env:
      HEAD_SHA: ${{ needs.deploy_cloud.outputs.head_sha }}
      TARGET_API_BASE_URL: ${{ needs.deploy_cloud.outputs.api_prod_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: API smoke verification
        run: node scripts/pipeline/cloud/deployment-stage/verify-api-smoke.mjs

      - name: Upload smoke artifacts
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: replay-production-smoke-${{ env.HEAD_SHA }}
          path: .artifacts/deploy/${{ env.HEAD_SHA }}/api-smoke.json
          if-no-files-found: warn

  release_decision:
    name: release-decision
    needs:
      - resolve_replay_source
      - load_release_candidate
      - deploy_cloud
      - production_smoke
    if: ${{ always() }}
    runs-on: ubuntu-latest
    env:
      HEAD_SHA: ${{ needs.load_release_candidate.outputs.head_sha || needs.resolve_replay_source.outputs.release_candidate_sha }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: Collect cloud deployment pipeline stage timing
        env:
          GITHUB_TOKEN: ${{ github.token }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          HEAD_SHA: ${{ env.HEAD_SHA }}
        run: node scripts/pipeline/shared/collect-cloud-deployment-stage-timing.mjs

      - name: Upload cloud deployment timing artifact
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: cloud-deployment-pipeline-replay-timing-${{ env.HEAD_SHA }}
          path: .artifacts/pipeline/${{ env.HEAD_SHA }}/timing.json
          if-no-files-found: warn

      - name: Write release decision artifact
        id: decision
        run: |
          set -euo pipefail

          mkdir -p ".artifacts/release/$HEAD_SHA"

          releasable="false"
          reason_codes='[]'

          if [ "${{ needs.resolve_replay_source.result }}" = "success" ] && \
             [ "${{ needs.load_release_candidate.result }}" = "success" ] && \
             [ "${{ needs.deploy_cloud.result }}" = "success" ] && \
             [ "${{ needs.production_smoke.result }}" = "success" ]; then
            releasable="true"
          else
            reason_codes='["CLOUD_DEPLOYMENT_REPLAY_FAILED"]'
          fi

          cat > ".artifacts/release/$HEAD_SHA/decision.json" <<JSON
          {
            "schemaVersion": "1",
            "generatedAt": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "headSha": "$HEAD_SHA",
            "replay": true,
            "releasable": ${releasable},
            "reasonCodes": ${reason_codes},
            "stages": {
              "resolveReplaySource": "${{ needs.resolve_replay_source.result }}",
              "loadReleaseCandidate": "${{ needs.load_release_candidate.result }}",
              "deployCloud": "${{ needs.deploy_cloud.result }}",
              "productionSmoke": "${{ needs.production_smoke.result }}"
            }
          }
          JSON

          echo "releasable=$releasable" >> "$GITHUB_OUTPUT"

      - name: Upload release decision artifact
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: replay-release-decision-${{ env.HEAD_SHA }}
          path: .artifacts/release/${{ env.HEAD_SHA }}/decision.json
          if-no-files-found: warn

      - name: Fail when release decision is NO
        if: ${{ steps.decision.outputs.releasable != 'true' }}
        run: |
          echo "Release decision is NO" >&2
          exit 1
