name: Cloud Deployment Pipeline

on:
  push:
    branches:
      - main

permissions:
  actions: read
  contents: read
  deployments: write
  id-token: write
  pull-requests: read

jobs:
  verify_commit_stage_evidence:
    name: verify-commit-stage-evidence
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      commit_stage_run_id: ${{ steps.verify.outputs.commit_stage_run_id }}
      commit_stage_evidence_path: ${{ steps.verify.outputs.commit_stage_evidence_path }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: Verify commit-stage evidence for release SHA
        id: verify
        env:
          GITHUB_TOKEN: ${{ github.token }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          HEAD_SHA: ${{ github.sha }}
          COMMIT_STAGE_WORKFLOW_FILE: commit-stage.yml
          COMMIT_STAGE_EVENT: push
        run: node scripts/pipeline/shared/verify-commit-stage-evidence.mjs

      - name: Upload commit-stage evidence artifact
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: commit-stage-evidence-${{ github.sha }}
          path: .artifacts/commit-stage/${{ github.sha }}/evidence.json
          if-no-files-found: warn

  verify_integration_gate_evidence:
    name: verify-integration-gate-evidence
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      integration_gate_run_id: ${{ steps.verify.outputs.integration_gate_run_id }}
      integration_gate_evidence_path: ${{ steps.verify.outputs.integration_gate_evidence_path }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: Verify integration gate evidence for release SHA
        id: verify
        env:
          GITHUB_TOKEN: ${{ github.token }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          HEAD_SHA: ${{ github.sha }}
          INTEGRATION_GATE_WORKFLOW_FILE: integration-gate.yml
          INTEGRATION_GATE_EVENT: push
        run: node scripts/pipeline/shared/verify-integration-gate-evidence.mjs

      - name: Upload integration gate evidence artifact
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: integration-gate-evidence-${{ github.sha }}
          path: .artifacts/integration-gate/${{ github.sha }}/evidence.json
          if-no-files-found: warn

  build_release_candidate_images:
    name: build-release-candidate-${{ matrix.service.name }}-image
    needs:
      - verify_commit_stage_evidence
      - verify_integration_gate_evidence
    runs-on: ubuntu-latest
    timeout-minutes: 60
    environment: production
    strategy:
      fail-fast: false
      matrix:
        service:
          - name: api
            image_name: compass-api
            dockerfile: apps/api/Dockerfile
          - name: web
            image_name: compass-web
            dockerfile: apps/web/Dockerfile
          - name: worker
            image_name: compass-worker
            dockerfile: apps/worker/Dockerfile
          - name: dynamic-sessions-runtime
            image_name: compass-codex-session-runtime
            dockerfile: apps/codex-session-runtime/Dockerfile
    env:
      HEAD_SHA: ${{ github.sha }}
      ACR_NAME: ${{ vars.ACR_NAME }}
      ACR_REGISTRY: ${{ format('{0}.azurecr.io', vars.ACR_NAME) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_GITHUB_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ACR login
        run: az acr login --name "$ACR_NAME" --only-show-errors

      - name: Build and push release candidate image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ matrix.service.dockerfile }}
          push: true
          tags: ${{ env.ACR_REGISTRY }}/${{ matrix.service.image_name }}:${{ env.HEAD_SHA }}
          cache-from: type=gha,scope=${{ matrix.service.image_name }}
          cache-to: type=gha,scope=${{ matrix.service.image_name }},mode=max

      - name: Write release candidate ref
        run: |
          set -euo pipefail
          mkdir -p ".artifacts/release-candidate/$HEAD_SHA"
          echo "${ACR_REGISTRY}/${{ matrix.service.image_name }}@${{ steps.build.outputs.digest }}" > ".artifacts/release-candidate/$HEAD_SHA/${{ matrix.service.name }}.ref"

      - name: Upload release candidate ref artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-candidate-ref-${{ matrix.service.name }}-${{ github.sha }}
          path: .artifacts/release-candidate/${{ env.HEAD_SHA }}/${{ matrix.service.name }}.ref
          if-no-files-found: error

  publish_release_candidate:
    name: publish-release-candidate
    needs:
      - verify_commit_stage_evidence
      - verify_integration_gate_evidence
      - build_release_candidate_images
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      head_sha: ${{ steps.publish.outputs.head_sha }}
      manifest_path: ${{ steps.publish.outputs.manifest_path }}
    env:
      HEAD_SHA: ${{ github.sha }}
      COMMIT_STAGE_RUN_ID: ${{ needs.verify_commit_stage_evidence.outputs.commit_stage_run_id }}
      INTEGRATION_GATE_RUN_ID: ${{ needs.verify_integration_gate_evidence.outputs.integration_gate_run_id }}
    steps:
      - name: Download release candidate ref artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: release-candidate-ref-*-${{ github.sha }}
          path: .artifacts/release-candidate/${{ env.HEAD_SHA }}
          merge-multiple: true

      - name: Publish release candidate manifest
        id: publish
        run: |
          set -euo pipefail

          artifact_dir=".artifacts/release-candidate/$HEAD_SHA"
          api_ref="$(cat "$artifact_dir/api.ref")"
          web_ref="$(cat "$artifact_dir/web.ref")"
          worker_ref="$(cat "$artifact_dir/worker.ref")"
          dynamic_sessions_runtime_ref="$(cat "$artifact_dir/dynamic-sessions-runtime.ref")"

          for image in "$api_ref" "$web_ref" "$worker_ref" "$dynamic_sessions_runtime_ref"; do
            if [[ "$image" != *"@sha256:"* ]]; then
              echo "Release candidate image reference must be digest-pinned: $image" >&2
              exit 1
            fi
          done

          manifest_path="$artifact_dir/manifest.json"
          cat > "$manifest_path" <<JSON
          {
            "schemaVersion": "1",
            "generatedAt": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "headSha": "$HEAD_SHA",
            "commitStageRunId": "$COMMIT_STAGE_RUN_ID",
            "integrationGateRunId": "$INTEGRATION_GATE_RUN_ID",
            "buildRunId": "${GITHUB_RUN_ID}",
            "releaseCandidate": {
              "apiRef": "$api_ref",
              "webRef": "$web_ref",
              "workerRef": "$worker_ref",
              "dynamicSessionsRuntimeRef": "$dynamic_sessions_runtime_ref"
            }
          }
          JSON

          echo "head_sha=$HEAD_SHA" >> "$GITHUB_OUTPUT"
          echo "manifest_path=$manifest_path" >> "$GITHUB_OUTPUT"

      - name: Upload release candidate artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-candidate-${{ env.HEAD_SHA }}
          path: .artifacts/release-candidate/${{ env.HEAD_SHA }}/manifest.json
          if-no-files-found: error

  deploy_cloud:
    name: deploy-cloud
    needs:
      - publish_release_candidate
    runs-on: ubuntu-latest
    timeout-minutes: 90
    environment: production
    concurrency:
      group: production-cloud-mutation
      cancel-in-progress: false
    outputs:
      head_sha: ${{ steps.set_head.outputs.head_sha }}
      api_prod_url: ${{ steps.resolve_urls.outputs.api_prod_url }}
      web_prod_url: ${{ steps.resolve_urls.outputs.web_prod_url }}
    env:
      HEAD_SHA: ${{ needs.publish_release_candidate.outputs.head_sha }}
      AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}
      AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
      AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
      KEY_VAULT_NAME: ${{ vars.KEY_VAULT_NAME }}
      TFSTATE_RESOURCE_GROUP: ${{ vars.TFSTATE_RESOURCE_GROUP }}
      TFSTATE_STORAGE_ACCOUNT: ${{ vars.TFSTATE_STORAGE_ACCOUNT }}
      TFSTATE_CONTAINER: ${{ vars.TFSTATE_CONTAINER }}
      TFSTATE_KEY: ${{ vars.TFSTATE_KEY }}
      API_IDENTIFIER_URI: ${{ vars.API_IDENTIFIER_URI }}
      IDENTITY_OWNER_OBJECT_IDS_JSON: ${{ vars.IDENTITY_OWNER_OBJECT_IDS_JSON }}
      ACA_WEB_CUSTOM_DOMAIN: ${{ vars.ACA_WEB_CUSTOM_DOMAIN }}
      IDENTITY_CONVERGE_ENABLED: ${{ vars.IDENTITY_CONVERGE_ENABLED || 'false' }}
      MIGRATION_TIMEOUT_SECONDS: ${{ vars.MIGRATION_TIMEOUT_SECONDS || '900' }}
      MIGRATION_CONTAINER_NAME: ${{ vars.MIGRATION_CONTAINER_NAME || 'migrate' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set head SHA output
        id: set_head
        run: echo "head_sha=$HEAD_SHA" >> "$GITHUB_OUTPUT"

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: Download release candidate artifact
        uses: actions/download-artifact@v4
        with:
          name: release-candidate-${{ env.HEAD_SHA }}
          path: .artifacts/release-candidate/${{ env.HEAD_SHA }}

      - name: Parse release candidate manifest
        run: |
          set -euo pipefail
          manifest_path=".artifacts/release-candidate/$HEAD_SHA/manifest.json"

          echo "API_IMAGE=$(jq -r '.releaseCandidate.apiRef' "$manifest_path")" >> "$GITHUB_ENV"
          echo "WEB_IMAGE=$(jq -r '.releaseCandidate.webRef' "$manifest_path")" >> "$GITHUB_ENV"
          echo "WORKER_IMAGE=$(jq -r '.releaseCandidate.workerRef' "$manifest_path")" >> "$GITHUB_ENV"
          echo "DYNAMIC_SESSIONS_RUNTIME_IMAGE=$(jq -r '.releaseCandidate.dynamicSessionsRuntimeRef' "$manifest_path")" >> "$GITHUB_ENV"

      - name: Validate release candidate refs
        run: |
          set -euo pipefail
          for image in "$API_IMAGE" "$WEB_IMAGE" "$WORKER_IMAGE" "$DYNAMIC_SESSIONS_RUNTIME_IMAGE"; do
            if [ -z "$image" ]; then
              echo "Missing release candidate image reference" >&2
              exit 1
            fi
            if [[ "$image" != *"@sha256:"* ]]; then
              echo "Release candidate image is not digest-pinned: $image" >&2
              exit 1
            fi
          done

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_GITHUB_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Validate Key Vault secret contract
        run: node scripts/pipeline/cloud/deployment-stage/validate-keyvault-secrets.mjs

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Converge identity (optional)
        env:
          ARM_USE_OIDC: "true"
          ARM_USE_AZUREAD: "true"
          ARM_CLIENT_ID: ${{ vars.AZURE_GITHUB_CLIENT_ID }}
          ARM_TENANT_ID: ${{ env.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ env.AZURE_SUBSCRIPTION_ID }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail

          if [ "${IDENTITY_CONVERGE_ENABLED,,}" != "true" ]; then
            echo "Identity converge is disabled; skipping."
            exit 0
          fi

          if [ -z "${TFSTATE_RESOURCE_GROUP:-}" ] || [ -z "${TFSTATE_STORAGE_ACCOUNT:-}" ] || [ -z "${TFSTATE_CONTAINER:-}" ] || [ -z "${TFSTATE_KEY:-}" ] || [ -z "${API_IDENTIFIER_URI:-}" ] || [ -z "${IDENTITY_OWNER_OBJECT_IDS_JSON:-}" ] || [ -z "${ACA_WEB_CUSTOM_DOMAIN:-}" ]; then
            echo "Identity converge is not configured in repository variables; skipping."
            exit 0
          fi

          gh_organization="${GITHUB_REPOSITORY%%/*}"
          gh_repository="${GITHUB_REPOSITORY##*/}"

          terraform -chdir=infra/identity init \
            -input=false \
            -backend-config="resource_group_name=${TFSTATE_RESOURCE_GROUP}" \
            -backend-config="storage_account_name=${TFSTATE_STORAGE_ACCOUNT}" \
            -backend-config="container_name=${TFSTATE_CONTAINER}" \
            -backend-config="key=${TFSTATE_KEY}" \
            -backend-config="use_oidc=true" \
            -backend-config="use_azuread_auth=true" \
            -backend-config="tenant_id=${ARM_TENANT_ID}" \
            -backend-config="subscription_id=${ARM_SUBSCRIPTION_ID}" \
            -backend-config="client_id=${ARM_CLIENT_ID}"

          terraform -chdir=infra/identity apply \
            -input=false \
            -auto-approve \
            -var-file=env/prod.tfvars \
            -var "github_organization=${gh_organization}" \
            -var "github_repository=${gh_repository}" \
            -var "github_environment_name=production" \
            -var "api_identifier_uri=${API_IDENTIFIER_URI}" \
            -var "owners=${IDENTITY_OWNER_OBJECT_IDS_JSON}" \
            -var "web_custom_domain=${ACA_WEB_CUSTOM_DOMAIN}"

          mkdir -p ".artifacts/identity/$HEAD_SHA"
          terraform -chdir=infra/identity output -json > ".artifacts/identity/$HEAD_SHA/outputs.json"

      - name: Apply infra
        run: |
          set -euo pipefail

          export ARM_TEMPLATE_FILE="infra/azure/main.bicep"
          export ARM_PARAMETERS_FILE="infra/azure/environments/cloud.bicepparam"
          export ARM_ARTIFACT_DIR=".artifacts/infra/$HEAD_SHA"
          export ARM_DEPLOYMENT_NAME_PREFIX="main"
          export ARM_PARAMETERS_OVERRIDES="$(cat <<PARAMS
          apiImage=$API_IMAGE
          webImage=$WEB_IMAGE
          workerImage=$WORKER_IMAGE
          dynamicSessionsRuntimeImage=$DYNAMIC_SESSIONS_RUNTIME_IMAGE
          PARAMS
          )"

          node scripts/pipeline/cloud/deployment-stage/apply-infra.mjs

      - name: Resolve deployed resource names
        id: resolve_runtime
        run: |
          set -euo pipefail

          deployment_json=".artifacts/infra/$HEAD_SHA/deployment.json"

          echo "ACA_API_APP_NAME=$(jq -er '.properties.outputs.apiContainerAppName.value' "$deployment_json")" >> "$GITHUB_ENV"
          echo "ACA_WEB_APP_NAME=$(jq -er '.properties.outputs.webContainerAppName.value' "$deployment_json")" >> "$GITHUB_ENV"
          echo "ACA_WORKER_APP_NAME=$(jq -er '.properties.outputs.workerContainerAppName.value' "$deployment_json")" >> "$GITHUB_ENV"
          echo "DYNAMIC_SESSIONS_POOL_NAME=$(jq -er '.properties.outputs.dynamicSessionsPoolNameOutput.value' "$deployment_json")" >> "$GITHUB_ENV"
          echo "DYNAMIC_SESSIONS_EXECUTOR_IDENTITY_NAME=$(jq -er '.properties.outputs.dynamicSessionsExecutorIdentityName.value' "$deployment_json")" >> "$GITHUB_ENV"
          echo "ACA_MIGRATE_JOB_NAME=$(jq -er '.properties.outputs.migrationJobName.value' "$deployment_json")" >> "$GITHUB_ENV"
          echo "SERVICE_BUS_PROD_NAMESPACE_NAME=$(jq -er '.properties.outputs.serviceBusProdNamespaceNameOutput.value' "$deployment_json")" >> "$GITHUB_ENV"
          echo "SERVICE_BUS_QUEUE_NAME=$(jq -er '.properties.outputs.serviceBusQueueNameOutput.value' "$deployment_json")" >> "$GITHUB_ENV"
          echo "WORKER_RUNTIME_IDENTITY_CLIENT_ID=$(jq -er '.properties.outputs.workerRuntimeIdentityClientId.value' "$deployment_json")" >> "$GITHUB_ENV"
          echo "WORKER_RUNTIME_IDENTITY_PRINCIPAL_ID=$(jq -er '.properties.outputs.workerRuntimeIdentityPrincipalId.value' "$deployment_json")" >> "$GITHUB_ENV"

      - name: Verify Dynamic Sessions convergence
        env:
          RELEASE_CANDIDATE_DYNAMIC_SESSIONS_RUNTIME_REF: ${{ env.DYNAMIC_SESSIONS_RUNTIME_IMAGE }}
        run: node scripts/pipeline/cloud/deployment-stage/verify-dynamic-sessions-convergence.mjs

      - name: Verify worker Service Bus cutover
        run: node scripts/pipeline/cloud/deployment-stage/verify-worker-servicebus-cutover.mjs

      - name: Update migration job image
        run: |
          az containerapp job update \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$ACA_MIGRATE_JOB_NAME" \
            --image "$API_IMAGE" \
            --output none

      - name: Run migration job
        id: migration_start
        env:
          AZURE_RESOURCE_GROUP: ${{ env.AZURE_RESOURCE_GROUP }}
          ACA_MIGRATE_JOB_NAME: ${{ env.ACA_MIGRATE_JOB_NAME }}
        run: node scripts/pipeline/cloud/deployment-stage/start-migration-job.mjs

      - name: Wait for migration completion
        env:
          AZURE_RESOURCE_GROUP: ${{ env.AZURE_RESOURCE_GROUP }}
          ACA_MIGRATE_JOB_NAME: ${{ env.ACA_MIGRATE_JOB_NAME }}
          MIGRATION_EXECUTION_NAME: ${{ steps.migration_start.outputs.migration_execution_name }}
          MIGRATION_TIMEOUT_SECONDS: ${{ env.MIGRATION_TIMEOUT_SECONDS }}
          MIGRATION_CONTAINER_NAME: ${{ env.MIGRATION_CONTAINER_NAME }}
        run: node scripts/pipeline/cloud/deployment-stage/wait-migration-job.mjs

      - name: Deploy API
        uses: azure/container-apps-deploy-action@v1
        with:
          imageToDeploy: ${{ env.API_IMAGE }}
          containerAppName: ${{ env.ACA_API_APP_NAME }}
          resourceGroup: ${{ env.AZURE_RESOURCE_GROUP }}
          disableTelemetry: true

      - name: Deploy Web
        uses: azure/container-apps-deploy-action@v1
        with:
          imageToDeploy: ${{ env.WEB_IMAGE }}
          containerAppName: ${{ env.ACA_WEB_APP_NAME }}
          resourceGroup: ${{ env.AZURE_RESOURCE_GROUP }}
          disableTelemetry: true

      - name: Deploy Worker
        uses: azure/container-apps-deploy-action@v1
        with:
          imageToDeploy: ${{ env.WORKER_IMAGE }}
          containerAppName: ${{ env.ACA_WORKER_APP_NAME }}
          resourceGroup: ${{ env.AZURE_RESOURCE_GROUP }}
          disableTelemetry: true

      - name: Resolve production URLs
        id: resolve_urls
        run: |
          set -euo pipefail

          api_prod_url="https://$(az containerapp show --resource-group "$AZURE_RESOURCE_GROUP" --name "$ACA_API_APP_NAME" --query 'properties.configuration.ingress.fqdn' --output tsv)"
          web_prod_url="https://$(az containerapp show --resource-group "$AZURE_RESOURCE_GROUP" --name "$ACA_WEB_APP_NAME" --query 'properties.configuration.ingress.fqdn' --output tsv)"

          echo "api_prod_url=$api_prod_url" >> "$GITHUB_OUTPUT"
          echo "web_prod_url=$web_prod_url" >> "$GITHUB_OUTPUT"

      - name: Upload deployment artifacts
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: deploy-cloud-${{ env.HEAD_SHA }}
          path: |
            .artifacts/infra/${{ env.HEAD_SHA }}
            .artifacts/identity/${{ env.HEAD_SHA }}
            .artifacts/deploy/${{ env.HEAD_SHA }}
          if-no-files-found: warn

  production_smoke:
    name: production-smoke
    needs:
      - deploy_cloud
    runs-on: ubuntu-latest
    timeout-minutes: 20
    environment: production
    env:
      HEAD_SHA: ${{ needs.deploy_cloud.outputs.head_sha }}
      TARGET_API_BASE_URL: ${{ needs.deploy_cloud.outputs.api_prod_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: API smoke verification
        run: node scripts/pipeline/cloud/deployment-stage/verify-api-smoke.mjs

      - name: Upload smoke artifacts
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: production-smoke-${{ env.HEAD_SHA }}
          path: .artifacts/deploy/${{ env.HEAD_SHA }}/api-smoke.json
          if-no-files-found: warn

  release_decision:
    name: release-decision
    needs:
      - verify_commit_stage_evidence
      - verify_integration_gate_evidence
      - publish_release_candidate
      - deploy_cloud
      - production_smoke
    if: ${{ always() }}
    runs-on: ubuntu-latest
    env:
      HEAD_SHA: ${{ needs.publish_release_candidate.outputs.head_sha || github.sha }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: Collect cloud deployment pipeline stage timing
        env:
          GITHUB_TOKEN: ${{ github.token }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          HEAD_SHA: ${{ env.HEAD_SHA }}
        run: node scripts/pipeline/shared/collect-cloud-deployment-stage-timing.mjs

      - name: Upload cloud deployment timing artifact
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: cloud-deployment-pipeline-timing-${{ env.HEAD_SHA }}
          path: .artifacts/pipeline/${{ env.HEAD_SHA }}/timing.json
          if-no-files-found: warn

      - name: Write release decision artifact
        id: decision
        run: |
          set -euo pipefail

          mkdir -p ".artifacts/release/$HEAD_SHA"

          releasable="false"
          reason_codes='[]'

          if [ "${{ needs.verify_commit_stage_evidence.result }}" = "success" ] && \
             [ "${{ needs.verify_integration_gate_evidence.result }}" = "success" ] && \
             [ "${{ needs.publish_release_candidate.result }}" = "success" ] && \
             [ "${{ needs.deploy_cloud.result }}" = "success" ] && \
             [ "${{ needs.production_smoke.result }}" = "success" ]; then
            releasable="true"
          else
            reason_codes='["CLOUD_DEPLOYMENT_PIPELINE_FAILED"]'
          fi

          cat > ".artifacts/release/$HEAD_SHA/decision.json" <<JSON
          {
            "schemaVersion": "1",
            "generatedAt": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "headSha": "$HEAD_SHA",
            "releasable": ${releasable},
            "reasonCodes": ${reason_codes},
            "stages": {
              "verifyCommitStageEvidence": "${{ needs.verify_commit_stage_evidence.result }}",
              "verifyIntegrationGateEvidence": "${{ needs.verify_integration_gate_evidence.result }}",
              "publishReleaseCandidate": "${{ needs.publish_release_candidate.result }}",
              "deployCloud": "${{ needs.deploy_cloud.result }}",
              "productionSmoke": "${{ needs.production_smoke.result }}"
            }
          }
          JSON

          echo "releasable=$releasable" >> "$GITHUB_OUTPUT"

      - name: Upload release decision artifact
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: release-decision-${{ env.HEAD_SHA }}
          path: .artifacts/release/${{ env.HEAD_SHA }}/decision.json
          if-no-files-found: warn

      - name: Fail when release decision is NO
        if: ${{ steps.decision.outputs.releasable != 'true' }}
        run: |
          echo "Release decision is NO" >&2
          exit 1
