name: Cloud Deployment Pipeline

on:
  push:
    branches:
      - main

permissions:
  actions: read
  contents: read
  deployments: write
  id-token: write
  pull-requests: read

env:
  EXPECTED_ENTRYPOINT: /

jobs:
  verify_commit_stage_evidence:
    name: verify-commit-stage-evidence
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      commit_stage_run_id: ${{ steps.verify.outputs.commit_stage_run_id }}
      commit_stage_evidence_path: ${{ steps.verify.outputs.commit_stage_evidence_path }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: Verify commit-stage evidence for release SHA
        id: verify
        env:
          GITHUB_TOKEN: ${{ github.token }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          HEAD_SHA: ${{ github.sha }}
          COMMIT_STAGE_WORKFLOW_FILE: commit-stage.yml
          COMMIT_STAGE_EVENT: push
        run: node scripts/pipeline/shared/verify-commit-stage-evidence.mjs

      - name: Upload commit-stage evidence artifact
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: commit-stage-evidence-${{ github.sha }}
          path: .artifacts/commit-stage/${{ github.sha }}/evidence.json
          if-no-files-found: warn

  verify_integration_gate_evidence:
    name: verify-integration-gate-evidence
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      integration_gate_run_id: ${{ steps.verify.outputs.integration_gate_run_id }}
      integration_gate_evidence_path: ${{ steps.verify.outputs.integration_gate_evidence_path }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: Verify integration gate evidence for release SHA
        id: verify
        env:
          GITHUB_TOKEN: ${{ github.token }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          HEAD_SHA: ${{ github.sha }}
          INTEGRATION_GATE_WORKFLOW_FILE: integration-gate.yml
          INTEGRATION_GATE_EVENT: push
        run: node scripts/pipeline/shared/verify-integration-gate-evidence.mjs

      - name: Upload integration gate evidence artifact
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: integration-gate-evidence-${{ github.sha }}
          path: .artifacts/integration-gate/${{ github.sha }}/evidence.json
          if-no-files-found: warn

  determine_scope:
    name: determine-scope
    needs:
      - verify_commit_stage_evidence
      - verify_integration_gate_evidence
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      scope_path: ${{ steps.scope.outputs.scope_path }}
      base_sha: ${{ steps.scope.outputs.base_sha }}
      head_sha: ${{ steps.scope.outputs.head_sha }}
      tested_sha: ${{ steps.scope.outputs.tested_sha }}
      pr_number: ${{ steps.scope.outputs.pr_number }}
      change_class: ${{ steps.scope.outputs.change_class }}
      runtime_changed: ${{ steps.scope.outputs.runtime_changed }}
      desktop_changed: ${{ steps.scope.outputs.desktop_changed }}
      infra_changed: ${{ steps.scope.outputs.infra_changed }}
      identity_changed: ${{ steps.scope.outputs.identity_changed }}
      migration_changed: ${{ steps.scope.outputs.migration_changed }}
      infra_rollout_changed: ${{ steps.scope.outputs.infra_rollout_changed }}
      docs_only_changed: ${{ steps.scope.outputs.docs_only_changed }}
      deployment_pipeline_config_changed: ${{ steps.scope.outputs.deployment_pipeline_config_changed }}
      requires_infra_convergence: ${{ steps.scope.outputs.requires_infra_convergence }}
      requires_migrations: ${{ steps.scope.outputs.requires_migrations }}
      changed_files_json: ${{ steps.scope.outputs.changed_files_json }}
      required_flow_ids_json: ${{ steps.scope.outputs.required_flow_ids_json }}
      docs_drift_blocking: ${{ steps.scope.outputs.docs_drift_blocking }}
      docs_drift_path: ${{ steps.docs_drift.outputs.docs_drift_path }}
      docs_drift_status: ${{ steps.docs_drift.outputs.docs_drift_status }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: Resolve commit scope
        id: scope
        env:
          GITHUB_BASE_SHA: ${{ github.event.before }}
          GITHUB_HEAD_SHA: ${{ github.sha }}
          GITHUB_TESTED_SHA: ${{ github.sha }}
        run: node scripts/pipeline/commit/resolve-scope.mjs

      - name: Upload scope artifact
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: commit-scope-${{ steps.scope.outputs.tested_sha }}
          path: ${{ steps.scope.outputs.scope_path }}
          if-no-files-found: warn

      - name: Evaluate docs drift
        id: docs_drift
        env:
          HEAD_SHA: ${{ steps.scope.outputs.head_sha }}
          TESTED_SHA: ${{ steps.scope.outputs.tested_sha }}
          CHANGED_FILES_JSON: ${{ steps.scope.outputs.changed_files_json }}
        run: node scripts/pipeline/commit/check-docs-drift.mjs

      - name: Upload docs-drift artifact
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: docs-drift-${{ steps.scope.outputs.tested_sha }}
          path: .artifacts/docs-drift/${{ steps.scope.outputs.tested_sha }}/result.json
          if-no-files-found: warn

  build_release_candidate_api_image:
    name: build-release-candidate-api-image
    needs:
      - determine_scope
    if: ${{ needs.determine_scope.outputs.runtime_changed == 'true' }}
    runs-on: ubuntu-latest
    timeout-minutes: 45
    environment: production
    outputs:
      release_candidate_api_ref: ${{ steps.set_ref.outputs.release_candidate_api_ref }}
    env:
      HEAD_SHA: ${{ needs.determine_scope.outputs.head_sha }}
      ACR_NAME: ${{ vars.ACR_NAME }}
      ACR_REGISTRY: ${{ format('{0}.azurecr.io', vars.ACR_NAME) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_DEPLOY_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ACR login
        run: az acr login --name "$ACR_NAME" --only-show-errors

      - name: Build and push release candidate API image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: apps/api/Dockerfile
          push: true
          tags: ${{ env.ACR_REGISTRY }}/compass-api:${{ env.HEAD_SHA }}
          cache-from: type=gha,scope=compass-api
          cache-to: type=gha,scope=compass-api,mode=max

      - name: Set release candidate API ref
        id: set_ref
        run: echo "release_candidate_api_ref=${ACR_REGISTRY}/compass-api@${{ steps.build.outputs.digest }}" >> "$GITHUB_OUTPUT"

  build_release_candidate_web_image:
    name: build-release-candidate-web-image
    needs:
      - determine_scope
    if: ${{ needs.determine_scope.outputs.runtime_changed == 'true' }}
    runs-on: ubuntu-latest
    timeout-minutes: 45
    environment: production
    outputs:
      release_candidate_web_ref: ${{ steps.set_ref.outputs.release_candidate_web_ref }}
    env:
      HEAD_SHA: ${{ needs.determine_scope.outputs.head_sha }}
      ACR_NAME: ${{ vars.ACR_NAME }}
      ACR_REGISTRY: ${{ format('{0}.azurecr.io', vars.ACR_NAME) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_DEPLOY_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ACR login
        run: az acr login --name "$ACR_NAME" --only-show-errors

      - name: Build and push release candidate Web image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: apps/web/Dockerfile
          push: true
          tags: ${{ env.ACR_REGISTRY }}/compass-web:${{ env.HEAD_SHA }}
          cache-from: type=gha,scope=compass-web
          cache-to: type=gha,scope=compass-web,mode=max

      - name: Set release candidate Web ref
        id: set_ref
        run: echo "release_candidate_web_ref=${ACR_REGISTRY}/compass-web@${{ steps.build.outputs.digest }}" >> "$GITHUB_OUTPUT"

  build_release_candidate_worker_image:
    name: build-release-candidate-worker-image
    needs:
      - determine_scope
    if: ${{ needs.determine_scope.outputs.runtime_changed == 'true' }}
    runs-on: ubuntu-latest
    timeout-minutes: 45
    environment: production
    outputs:
      release_candidate_worker_ref: ${{ steps.set_ref.outputs.release_candidate_worker_ref }}
    env:
      HEAD_SHA: ${{ needs.determine_scope.outputs.head_sha }}
      ACR_NAME: ${{ vars.ACR_NAME }}
      ACR_REGISTRY: ${{ format('{0}.azurecr.io', vars.ACR_NAME) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_DEPLOY_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ACR login
        run: az acr login --name "$ACR_NAME" --only-show-errors

      - name: Build and push release candidate Worker image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: apps/worker/Dockerfile
          push: true
          tags: ${{ env.ACR_REGISTRY }}/compass-worker:${{ env.HEAD_SHA }}
          cache-from: type=gha,scope=compass-worker
          cache-to: type=gha,scope=compass-worker,mode=max

      - name: Set release candidate Worker ref
        id: set_ref
        run: echo "release_candidate_worker_ref=${ACR_REGISTRY}/compass-worker@${{ steps.build.outputs.digest }}" >> "$GITHUB_OUTPUT"

  build_release_candidate_codex_image:
    name: build-release-candidate-codex-image
    needs:
      - determine_scope
    if: ${{ needs.determine_scope.outputs.runtime_changed == 'true' }}
    runs-on: ubuntu-latest
    timeout-minutes: 45
    environment: production
    outputs:
      release_candidate_codex_ref: ${{ steps.set_ref.outputs.release_candidate_codex_ref }}
    env:
      HEAD_SHA: ${{ needs.determine_scope.outputs.head_sha }}
      ACR_NAME: ${{ vars.ACR_NAME }}
      ACR_REGISTRY: ${{ format('{0}.azurecr.io', vars.ACR_NAME) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_DEPLOY_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ACR login
        run: az acr login --name "$ACR_NAME" --only-show-errors

      - name: Build and push release candidate Codex image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: apps/codex-app-server/Dockerfile
          push: true
          tags: ${{ env.ACR_REGISTRY }}/compass-codex-app-server:${{ env.HEAD_SHA }}
          cache-from: type=gha,scope=compass-codex-app-server
          cache-to: type=gha,scope=compass-codex-app-server,mode=max

      - name: Set release candidate Codex ref
        id: set_ref
        run: echo "release_candidate_codex_ref=${ACR_REGISTRY}/compass-codex-app-server@${{ steps.build.outputs.digest }}" >> "$GITHUB_OUTPUT"

  capture_current_runtime_refs:
    name: capture-current-runtime-refs
    needs:
      - determine_scope
    if: ${{ needs.determine_scope.outputs.runtime_changed != 'true' && (needs.determine_scope.outputs.infra_changed == 'true' || needs.determine_scope.outputs.requires_infra_convergence == 'true') }}
    runs-on: ubuntu-latest
    timeout-minutes: 20
    environment: production
    outputs:
      release_candidate_api_ref: ${{ steps.freeze.outputs.release_candidate_api_ref }}
      release_candidate_web_ref: ${{ steps.freeze.outputs.release_candidate_web_ref }}
      release_candidate_worker_ref: ${{ steps.freeze.outputs.release_candidate_worker_ref }}
      release_candidate_codex_ref: ${{ steps.freeze.outputs.release_candidate_codex_ref }}
    env:
      ACR_NAME: ${{ vars.ACR_NAME }}
      AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
      ACA_API_APP_NAME: ${{ vars.ACA_API_APP_NAME }}
      ACA_WEB_APP_NAME: ${{ vars.ACA_WEB_APP_NAME }}
      ACA_WORKER_APP_NAME: ${{ vars.ACA_WORKER_APP_NAME }}
      ACA_CODEX_APP_NAME: ${{ vars.ACA_CODEX_APP_NAME }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_DEPLOY_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Freeze current runtime refs
        id: freeze
        env:
          FREEZE_MODE: resolve-current-runtime-refs
        run: node scripts/pipeline/shared/freeze-release-candidate-refs.mjs

  publish_release_candidate:
    name: publish-release-candidate
    needs:
      - verify_commit_stage_evidence
      - verify_integration_gate_evidence
      - determine_scope
      - build_release_candidate_api_image
      - build_release_candidate_web_image
      - build_release_candidate_worker_image
      - build_release_candidate_codex_image
      - capture_current_runtime_refs
    if: ${{ always() && needs.verify_commit_stage_evidence.result == 'success' && needs.verify_integration_gate_evidence.result == 'success' && needs.determine_scope.result == 'success' && ((needs.determine_scope.outputs.runtime_changed == 'true' && needs.build_release_candidate_api_image.result == 'success' && needs.build_release_candidate_web_image.result == 'success' && needs.build_release_candidate_worker_image.result == 'success' && needs.build_release_candidate_codex_image.result == 'success') || ((needs.determine_scope.outputs.infra_changed == 'true' || needs.determine_scope.outputs.requires_infra_convergence == 'true') && needs.capture_current_runtime_refs.result == 'success') || (needs.determine_scope.outputs.runtime_changed != 'true' && needs.determine_scope.outputs.infra_changed != 'true' && needs.determine_scope.outputs.requires_infra_convergence != 'true')) }}
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      head_sha: ${{ steps.publish.outputs.head_sha }}
    env:
      HEAD_SHA: ${{ needs.determine_scope.outputs.head_sha }}
      TESTED_SHA: ${{ needs.determine_scope.outputs.tested_sha }}
      CHANGE_CLASS: ${{ needs.determine_scope.outputs.change_class }}
      COMMIT_STAGE_RUN_ID: ${{ needs.verify_commit_stage_evidence.outputs.commit_stage_run_id }}
      INTEGRATION_GATE_RUN_ID: ${{ needs.verify_integration_gate_evidence.outputs.integration_gate_run_id }}
      RUNTIME_CHANGED: ${{ needs.determine_scope.outputs.runtime_changed }}
      DESKTOP_CHANGED: ${{ needs.determine_scope.outputs.desktop_changed }}
      INFRA_CHANGED: ${{ needs.determine_scope.outputs.infra_changed }}
      IDENTITY_CHANGED: ${{ needs.determine_scope.outputs.identity_changed }}
      DOCS_ONLY_CHANGED: ${{ needs.determine_scope.outputs.docs_only_changed }}
      REQUIRES_INFRA_CONVERGENCE: ${{ needs.determine_scope.outputs.requires_infra_convergence }}
      REQUIRES_MIGRATIONS: ${{ needs.determine_scope.outputs.requires_migrations }}
      RELEASE_CANDIDATE_API_REF: ${{ needs.determine_scope.outputs.runtime_changed == 'true' && needs.build_release_candidate_api_image.outputs.release_candidate_api_ref || needs.capture_current_runtime_refs.outputs.release_candidate_api_ref }}
      RELEASE_CANDIDATE_WEB_REF: ${{ needs.determine_scope.outputs.runtime_changed == 'true' && needs.build_release_candidate_web_image.outputs.release_candidate_web_ref || needs.capture_current_runtime_refs.outputs.release_candidate_web_ref }}
      RELEASE_CANDIDATE_WORKER_REF: ${{ needs.determine_scope.outputs.runtime_changed == 'true' && needs.build_release_candidate_worker_image.outputs.release_candidate_worker_ref || needs.capture_current_runtime_refs.outputs.release_candidate_worker_ref }}
      RELEASE_CANDIDATE_CODEX_REF: ${{ needs.determine_scope.outputs.runtime_changed == 'true' && needs.build_release_candidate_codex_image.outputs.release_candidate_codex_ref || needs.capture_current_runtime_refs.outputs.release_candidate_codex_ref }}
      FREEZE_API_RESULT: ${{ needs.build_release_candidate_api_image.result }}
      FREEZE_WEB_RESULT: ${{ needs.build_release_candidate_web_image.result }}
      FREEZE_WORKER_RESULT: ${{ needs.build_release_candidate_worker_image.result }}
      FREEZE_CODEX_RESULT: ${{ needs.build_release_candidate_codex_image.result }}
      FREEZE_CURRENT_REFS_RESULT: ${{ needs.capture_current_runtime_refs.result }}
    steps:
      - name: Publish release candidate manifest
        id: publish
        run: |
          set -euo pipefail

          artifact_dir=".artifacts/release-candidate/$HEAD_SHA"
          mkdir -p "$artifact_dir"

          requires_refs=false
          if [ "$RUNTIME_CHANGED" = "true" ] || [ "$INFRA_CHANGED" = "true" ] || [ "$REQUIRES_INFRA_CONVERGENCE" = "true" ]; then
            requires_refs=true
          fi

          if [ "$RUNTIME_CHANGED" = "true" ]; then
            if [ "$FREEZE_API_RESULT" != "success" ] || [ "$FREEZE_WEB_RESULT" != "success" ] || [ "$FREEZE_WORKER_RESULT" != "success" ] || [ "$FREEZE_CODEX_RESULT" != "success" ]; then
              echo "Runtime release candidate refs are required but runtime freeze jobs did not all succeed." >&2
              exit 1
            fi
          elif [ "$INFRA_CHANGED" = "true" ] || [ "$REQUIRES_INFRA_CONVERGENCE" = "true" ]; then
            if [ "$FREEZE_CURRENT_REFS_RESULT" != "success" ]; then
              echo "Current runtime refs are required but capture-current-runtime-refs did not succeed." >&2
              exit 1
            fi
          fi

          if [ "$requires_refs" = "true" ]; then
            if [ -z "${RELEASE_CANDIDATE_API_REF:-}" ] || [ -z "${RELEASE_CANDIDATE_WEB_REF:-}" ] || [ -z "${RELEASE_CANDIDATE_WORKER_REF:-}" ] || [ -z "${RELEASE_CANDIDATE_CODEX_REF:-}" ]; then
              echo "Release candidate refs are required but missing." >&2
              exit 1
            fi
          fi

          cat > "$artifact_dir/manifest.json" <<JSON
          {
            "schemaVersion": "1",
            "generatedAt": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "headSha": "$HEAD_SHA",
            "testedSha": "$TESTED_SHA",
            "changeClass": "$CHANGE_CLASS",
            "commitStageRunId": "$COMMIT_STAGE_RUN_ID",
            "integrationGateRunId": "$INTEGRATION_GATE_RUN_ID",
            "buildRunId": "${GITHUB_RUN_ID}",
            "scope": {
              "runtime": ${RUNTIME_CHANGED},
              "desktop": ${DESKTOP_CHANGED},
              "infra": ${INFRA_CHANGED},
              "identity": ${IDENTITY_CHANGED},
              "docsOnly": ${DOCS_ONLY_CHANGED}
            },
            "requiresInfraConvergence": ${REQUIRES_INFRA_CONVERGENCE},
            "requiresMigrations": ${REQUIRES_MIGRATIONS},
            "releaseCandidate": {
              "apiRef": "${RELEASE_CANDIDATE_API_REF:-}",
              "webRef": "${RELEASE_CANDIDATE_WEB_REF:-}",
              "workerRef": "${RELEASE_CANDIDATE_WORKER_REF:-}",
              "codexRef": "${RELEASE_CANDIDATE_CODEX_REF:-}"
            }
          }
          JSON

          echo "head_sha=$HEAD_SHA" >> "$GITHUB_OUTPUT"

      - name: Upload release candidate artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-candidate-${{ env.HEAD_SHA }}
          path: .artifacts/release-candidate/${{ env.HEAD_SHA }}/manifest.json
          if-no-files-found: error

  load_release_candidate:
    name: load-release-candidate
    needs:
      - determine_scope
      - publish_release_candidate
    if: ${{ always() && needs.publish_release_candidate.result == 'success' }}
    runs-on: ubuntu-latest
    outputs:
      head_sha: ${{ steps.manifest.outputs.head_sha }}
      change_class: ${{ steps.manifest.outputs.change_class }}
      runtime_changed: ${{ steps.manifest.outputs.runtime_changed }}
      desktop_changed: ${{ steps.manifest.outputs.desktop_changed }}
      infra_changed: ${{ steps.manifest.outputs.infra_changed }}
      identity_changed: ${{ steps.manifest.outputs.identity_changed }}
      docs_only_changed: ${{ steps.manifest.outputs.docs_only_changed }}
      requires_infra_convergence: ${{ steps.manifest.outputs.requires_infra_convergence }}
      requires_migrations: ${{ steps.manifest.outputs.requires_migrations }}
      release_candidate_api_ref: ${{ steps.manifest.outputs.release_candidate_api_ref }}
      release_candidate_web_ref: ${{ steps.manifest.outputs.release_candidate_web_ref }}
      release_candidate_worker_ref: ${{ steps.manifest.outputs.release_candidate_worker_ref }}
      release_candidate_codex_ref: ${{ steps.manifest.outputs.release_candidate_codex_ref }}
      commit_run_id: ${{ steps.manifest.outputs.commit_run_id }}
      release_candidate_ref_contract_status: ${{ steps.manifest.outputs.release_candidate_ref_contract_status }}
      release_candidate_ref_contract_reason_codes_json: ${{ steps.manifest.outputs.release_candidate_ref_contract_reason_codes_json }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: Download release candidate artifact
        uses: actions/download-artifact@v4
        with:
          name: release-candidate-${{ needs.determine_scope.outputs.head_sha }}
          path: .artifacts/release-candidate/${{ needs.determine_scope.outputs.head_sha }}

      - name: Parse release candidate manifest
        id: manifest
        env:
          RELEASE_CANDIDATE_MANIFEST_PATH: .artifacts/release-candidate/${{ needs.determine_scope.outputs.head_sha }}/manifest.json
          RUN_ID: ${{ github.run_id }}
        run: node scripts/pipeline/shared/load-release-candidate-contract.mjs

      - name: Upload release candidate manifest copy
        uses: actions/upload-artifact@v4
        with:
          name: deployment-pipeline-release-candidate-${{ steps.manifest.outputs.head_sha }}
          path: ${{ steps.manifest.outputs.release_candidate_manifest_copy_path }}
          if-no-files-found: error

  runtime_api_system_acceptance:
    name: runtime-api-system-acceptance
    needs:
      - load_release_candidate
    if: ${{ always() && needs.load_release_candidate.result == 'success' }}
    runs-on: ubuntu-latest
    timeout-minutes: 45
    environment: acceptance
    env:
      HEAD_SHA: ${{ needs.load_release_candidate.outputs.head_sha }}
      TESTED_SHA: ${{ needs.load_release_candidate.outputs.head_sha }}
      RELEASE_CANDIDATE_API_REF: ${{ needs.load_release_candidate.outputs.release_candidate_api_ref }}
      RELEASE_CANDIDATE_WEB_REF: ${{ needs.load_release_candidate.outputs.release_candidate_web_ref }}
      RELEASE_CANDIDATE_WORKER_REF: ${{ needs.load_release_candidate.outputs.release_candidate_worker_ref }}
      RELEASE_CANDIDATE_CODEX_REF: ${{ needs.load_release_candidate.outputs.release_candidate_codex_ref }}
      RELEASE_CANDIDATE_REF_CONTRACT_STATUS: ${{ needs.load_release_candidate.outputs.release_candidate_ref_contract_status }}
      AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}
      AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
      ACR_NAME: ${{ vars.ACR_NAME }}
      JOB_REQUIRED: ${{ needs.load_release_candidate.outputs.runtime_changed == 'true' && needs.load_release_candidate.outputs.docs_only_changed != 'true' }}
    steps:
      - name: Record not-required runtime API/system acceptance
        if: ${{ env.JOB_REQUIRED != 'true' }}
        run: |
          set -euo pipefail
          mkdir -p ".artifacts/runtime-api-system/$HEAD_SHA"
          cat > ".artifacts/runtime-api-system/$HEAD_SHA/result.json" <<JSON
          {
            "schemaVersion": "1",
            "generatedAt": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "headSha": "$HEAD_SHA",
            "status": "not-required",
            "reasonCode": "RUNTIME_API_SYSTEM_NOT_REQUIRED"
          }
          JSON

      - name: Checkout
        if: ${{ env.JOB_REQUIRED == 'true' }}
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node + pnpm
        if: ${{ env.JOB_REQUIRED == 'true' }}
        uses: ./.github/actions/setup-node-pnpm

      - name: Azure login for runtime release candidate pull
        if: ${{ env.JOB_REQUIRED == 'true' }}
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_ACCEPTANCE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Run API/system acceptance against release candidate API image
        if: ${{ env.JOB_REQUIRED == 'true' }}
        run: node scripts/pipeline/cloud/automated-acceptance-test-gate/run-runtime-api-system-acceptance.mjs

      - name: Upload runtime API/system acceptance artifacts
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: runtime-api-system-acceptance-${{ env.HEAD_SHA }}
          path: |
            .artifacts/runtime-api-system/${{ env.HEAD_SHA }}
            .artifacts/harness-smoke/${{ env.TESTED_SHA }}/result.json
            .artifacts/codex-smoke/${{ env.TESTED_SHA }}/result.json
            .artifacts/deploy/${{ env.TESTED_SHA }}/api-smoke.json
          if-no-files-found: warn

  runtime_browser_acceptance:
    name: runtime-browser-acceptance
    needs:
      - load_release_candidate
    if: ${{ always() && needs.load_release_candidate.result == 'success' }}
    runs-on: ubuntu-latest
    timeout-minutes: 45
    environment: acceptance
    strategy:
      matrix:
        flow_id:
          - compass-smoke
      fail-fast: false
    env:
      HEAD_SHA: ${{ needs.load_release_candidate.outputs.head_sha }}
      TESTED_SHA: ${{ needs.load_release_candidate.outputs.head_sha }}
      EVIDENCE_FLOW_ID: ${{ matrix.flow_id }}
      RELEASE_CANDIDATE_API_REF: ${{ needs.load_release_candidate.outputs.release_candidate_api_ref }}
      RELEASE_CANDIDATE_WEB_REF: ${{ needs.load_release_candidate.outputs.release_candidate_web_ref }}
      RELEASE_CANDIDATE_WORKER_REF: ${{ needs.load_release_candidate.outputs.release_candidate_worker_ref }}
      RELEASE_CANDIDATE_CODEX_REF: ${{ needs.load_release_candidate.outputs.release_candidate_codex_ref }}
      RELEASE_CANDIDATE_REF_CONTRACT_STATUS: ${{ needs.load_release_candidate.outputs.release_candidate_ref_contract_status }}
      AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}
      AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
      ACR_NAME: ${{ vars.ACR_NAME }}
      JOB_REQUIRED: ${{ needs.load_release_candidate.outputs.runtime_changed == 'true' && needs.load_release_candidate.outputs.docs_only_changed != 'true' }}
    steps:
      - name: Record not-required runtime browser acceptance
        if: ${{ env.JOB_REQUIRED != 'true' }}
        run: |
          set -euo pipefail
          mkdir -p ".artifacts/runtime-browser/$HEAD_SHA"
          cat > ".artifacts/runtime-browser/$HEAD_SHA/result.json" <<JSON
          {
            "schemaVersion": "1",
            "generatedAt": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "headSha": "$HEAD_SHA",
            "flowId": "$EVIDENCE_FLOW_ID",
            "status": "not-required",
            "reasonCode": "RUNTIME_BROWSER_NOT_REQUIRED"
          }
          JSON

      - name: Checkout
        if: ${{ env.JOB_REQUIRED == 'true' }}
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node + pnpm
        if: ${{ env.JOB_REQUIRED == 'true' }}
        uses: ./.github/actions/setup-node-pnpm

      - name: Install Playwright browser
        if: ${{ env.JOB_REQUIRED == 'true' }}
        run: pnpm exec playwright install --with-deps chromium

      - name: Azure login for runtime release candidate pull
        if: ${{ env.JOB_REQUIRED == 'true' }}
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_ACCEPTANCE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Run browser acceptance against release candidate Web image
        if: ${{ env.JOB_REQUIRED == 'true' }}
        run: node scripts/pipeline/cloud/automated-acceptance-test-gate/run-runtime-browser-acceptance.mjs

      - name: Upload runtime browser acceptance artifacts
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: runtime-browser-acceptance-${{ env.HEAD_SHA }}-${{ matrix.flow_id }}
          path: |
            .artifacts/runtime-browser/${{ env.HEAD_SHA }}
            .artifacts/browser-evidence/${{ env.TESTED_SHA }}
          if-no-files-found: warn

  runtime_migration_image_acceptance:
    name: runtime-migration-image-acceptance
    needs:
      - load_release_candidate
    if: ${{ always() && needs.load_release_candidate.result == 'success' }}
    runs-on: ubuntu-latest
    timeout-minutes: 25
    environment: acceptance
    env:
      HEAD_SHA: ${{ needs.load_release_candidate.outputs.head_sha }}
      RELEASE_CANDIDATE_API_REF: ${{ needs.load_release_candidate.outputs.release_candidate_api_ref }}
      RELEASE_CANDIDATE_WEB_REF: ${{ needs.load_release_candidate.outputs.release_candidate_web_ref }}
      RELEASE_CANDIDATE_WORKER_REF: ${{ needs.load_release_candidate.outputs.release_candidate_worker_ref }}
      RELEASE_CANDIDATE_CODEX_REF: ${{ needs.load_release_candidate.outputs.release_candidate_codex_ref }}
      RELEASE_CANDIDATE_REF_CONTRACT_STATUS: ${{ needs.load_release_candidate.outputs.release_candidate_ref_contract_status }}
      AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}
      AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
      ACR_NAME: ${{ vars.ACR_NAME }}
      JOB_REQUIRED: ${{ needs.load_release_candidate.outputs.runtime_changed == 'true' && needs.load_release_candidate.outputs.docs_only_changed != 'true' }}
    steps:
      - name: Record not-required runtime migration acceptance
        if: ${{ env.JOB_REQUIRED != 'true' }}
        run: |
          set -euo pipefail
          mkdir -p ".artifacts/migration-image-smoke/$HEAD_SHA"
          cat > ".artifacts/migration-image-smoke/$HEAD_SHA/result.json" <<JSON
          {
            "schemaVersion": "1",
            "generatedAt": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "headSha": "$HEAD_SHA",
            "status": "not-required",
            "reasonCode": "RUNTIME_MIGRATION_IMAGE_NOT_REQUIRED"
          }
          JSON

      - name: Checkout
        if: ${{ env.JOB_REQUIRED == 'true' }}
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        if: ${{ env.JOB_REQUIRED == 'true' }}
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: Azure login for runtime release candidate pull
        if: ${{ env.JOB_REQUIRED == 'true' }}
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_ACCEPTANCE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Run migration-image acceptance against release candidate API image
        if: ${{ env.JOB_REQUIRED == 'true' }}
        run: node scripts/pipeline/cloud/automated-acceptance-test-gate/run-runtime-migration-image-acceptance.mjs

      - name: Upload migration-image acceptance artifacts
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: runtime-migration-image-acceptance-${{ env.HEAD_SHA }}
          path: .artifacts/migration-image-smoke/${{ env.HEAD_SHA }}
          if-no-files-found: warn

  infra_readonly_acceptance:
    name: infra-readonly-acceptance
    needs:
      - load_release_candidate
    if: ${{ always() && needs.load_release_candidate.result == 'success' }}
    runs-on: ubuntu-latest
    timeout-minutes: 30
    environment: acceptance
    env:
      HEAD_SHA: ${{ needs.load_release_candidate.outputs.head_sha }}
      API_IMAGE: ${{ needs.load_release_candidate.outputs.release_candidate_api_ref }}
      WEB_IMAGE: ${{ needs.load_release_candidate.outputs.release_candidate_web_ref }}
      WORKER_IMAGE: ${{ needs.load_release_candidate.outputs.release_candidate_worker_ref }}
      CODEX_IMAGE: ${{ needs.load_release_candidate.outputs.release_candidate_codex_ref }}
      RELEASE_CANDIDATE_REF_CONTRACT_STATUS: ${{ needs.load_release_candidate.outputs.release_candidate_ref_contract_status }}
      RELEASE_CANDIDATE_REF_CONTRACT_REASON_CODES_JSON: ${{ needs.load_release_candidate.outputs.release_candidate_ref_contract_reason_codes_json }}
      AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}
      AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
      AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
      AZURE_LOCATION: ${{ vars.AZURE_LOCATION }}
      AZURE_VNET_NAME: ${{ vars.AZURE_VNET_NAME }}
      AZURE_ACA_SUBNET_NAME: ${{ vars.AZURE_ACA_SUBNET_NAME }}
      AZURE_POSTGRES_SUBNET_NAME: ${{ vars.AZURE_POSTGRES_SUBNET_NAME }}
      AZURE_PRIVATE_DNS_ZONE_NAME: ${{ vars.AZURE_PRIVATE_DNS_ZONE_NAME }}
      ACA_ENVIRONMENT_NAME: ${{ vars.ACA_ENVIRONMENT_NAME }}
      AZURE_LOG_ANALYTICS_WORKSPACE_NAME: ${{ vars.AZURE_LOG_ANALYTICS_WORKSPACE_NAME }}
      ACA_API_APP_NAME: ${{ vars.ACA_API_APP_NAME }}
      ACA_WEB_APP_NAME: ${{ vars.ACA_WEB_APP_NAME }}
      ACA_WORKER_APP_NAME: ${{ vars.ACA_WORKER_APP_NAME }}
      ACA_CODEX_APP_NAME: ${{ vars.ACA_CODEX_APP_NAME }}
      ACA_API_CUSTOM_DOMAIN: ${{ vars.ACA_API_CUSTOM_DOMAIN }}
      ACA_WEB_CUSTOM_DOMAIN: ${{ vars.ACA_WEB_CUSTOM_DOMAIN }}
      ACA_CODEX_CUSTOM_DOMAIN: ${{ vars.ACA_CODEX_CUSTOM_DOMAIN }}
      ACA_MIGRATE_JOB_NAME: ${{ vars.ACA_MIGRATE_JOB_NAME }}
      ACR_PULL_IDENTITY_NAME: ${{ vars.ACR_PULL_IDENTITY_NAME }}
      ACR_NAME: ${{ vars.ACR_NAME }}
      POSTGRES_SERVER_NAME: ${{ vars.POSTGRES_SERVER_NAME }}
      POSTGRES_DATABASE_NAME: ${{ vars.POSTGRES_DATABASE_NAME }}
      POSTGRES_ADMIN_USERNAME: ${{ vars.POSTGRES_ADMIN_USERNAME }}
      POSTGRES_ADMIN_PASSWORD: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
      WEB_SESSION_SECRET: ${{ secrets.WEB_SESSION_SECRET }}
      ENTRA_LOGIN_ENABLED: ${{ vars.ENTRA_LOGIN_ENABLED }}
      ENTRA_CLIENT_ID: ${{ vars.ENTRA_CLIENT_ID }}
      ENTRA_CLIENT_SECRET: ${{ secrets.ENTRA_CLIENT_SECRET }}
      ENTRA_ALLOWED_TENANT_IDS: ${{ vars.ENTRA_ALLOWED_TENANT_IDS }}
      AUTH_DEV_FALLBACK_ENABLED: ${{ vars.AUTH_DEV_FALLBACK_ENABLED }}
      JOB_REQUIRED: ${{ (needs.load_release_candidate.outputs.infra_changed == 'true' || needs.load_release_candidate.outputs.requires_infra_convergence == 'true') && needs.load_release_candidate.outputs.docs_only_changed != 'true' }}
      API_IDENTIFIER_URI: ${{ vars.API_IDENTIFIER_URI }}
      AUTH_AUDIENCE: ${{ vars.AUTH_AUDIENCE }}
      AUTH_ALLOWED_CLIENT_IDS: ${{ vars.AUTH_ALLOWED_CLIENT_IDS }}
      AUTH_ACTIVE_TENANT_IDS: ${{ vars.AUTH_ACTIVE_TENANT_IDS }}
      OAUTH_TOKEN_ISSUER: ${{ vars.OAUTH_TOKEN_ISSUER }}
      OAUTH_TOKEN_AUDIENCE: ${{ vars.OAUTH_TOKEN_AUDIENCE }}
      OAUTH_TOKEN_SIGNING_SECRET: ${{ secrets.OAUTH_TOKEN_SIGNING_SECRET }}
      AUTH_BOOTSTRAP_ALLOWED_TENANT_ID: ${{ vars.API_SMOKE_ALLOWED_TENANT_ID }}
      AUTH_BOOTSTRAP_ALLOWED_APP_CLIENT_ID: ${{ secrets.API_SMOKE_ALLOWED_CLIENT_ID }}
      AUTH_BOOTSTRAP_DELEGATED_USER_OID: ${{ vars.AUTH_BOOTSTRAP_DELEGATED_USER_OID }}
      AUTH_BOOTSTRAP_DELEGATED_USER_EMAIL: ${{ vars.AUTH_BOOTSTRAP_DELEGATED_USER_EMAIL }}
      WORKER_RUNTIME_IDENTITY_NAME: ${{ vars.WORKER_RUNTIME_IDENTITY_NAME }}
      SERVICE_BUS_PROD_NAMESPACE_NAME: ${{ vars.SERVICE_BUS_PROD_NAMESPACE_NAME }}
      SERVICE_BUS_ACCEPTANCE_NAMESPACE_NAME: ${{ vars.SERVICE_BUS_ACCEPTANCE_NAMESPACE_NAME }}
      SERVICE_BUS_QUEUE_NAME: ${{ vars.SERVICE_BUS_QUEUE_NAME }}
      WORKER_RUN_MODE: ${{ vars.WORKER_RUN_MODE }}
    steps:
      - name: Record not-required infra acceptance
        if: ${{ env.JOB_REQUIRED != 'true' }}
        run: |
          set -euo pipefail
          mkdir -p ".artifacts/infra/$HEAD_SHA"
          cat > ".artifacts/infra/$HEAD_SHA/acceptance-not-required.json" <<JSON
          {
            "schemaVersion": "1",
            "generatedAt": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "headSha": "$HEAD_SHA",
            "status": "not-required",
            "reasonCode": "INFRA_READONLY_ACCEPTANCE_NOT_REQUIRED"
          }
          JSON

      - name: Checkout
        if: ${{ env.JOB_REQUIRED == 'true' }}
        uses: actions/checkout@v4

      - name: Validate release candidate references for infra acceptance
        if: ${{ env.JOB_REQUIRED == 'true' }}
        run: |
          set -euo pipefail

          if [ "${RELEASE_CANDIDATE_REF_CONTRACT_STATUS:-unknown}" != "pass" ]; then
            echo "Release candidate ref contract status is ${RELEASE_CANDIDATE_REF_CONTRACT_STATUS:-unknown}" >&2
            echo "Reason codes: ${RELEASE_CANDIDATE_REF_CONTRACT_REASON_CODES_JSON:-[]}" >&2
            exit 1
          fi

          for image in "$API_IMAGE" "$WEB_IMAGE" "$WORKER_IMAGE" "$CODEX_IMAGE"; do
            if [ -z "$image" ]; then
              echo "Release candidate image reference is missing for infra acceptance" >&2
              exit 1
            fi
            if [[ "$image" != *"@sha256:"* ]]; then
              echo "Release candidate image is not a digest reference: $image" >&2
              exit 1
            fi
          done

      - name: Azure login (OIDC)
        if: ${{ env.JOB_REQUIRED == 'true' }}
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_ACCEPTANCE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Validate required environment configuration
        if: ${{ env.JOB_REQUIRED == 'true' }}
        run: node scripts/pipeline/shared/validate-infra-acceptance-config.mjs

      - name: Render infra parameters
        if: ${{ env.JOB_REQUIRED == 'true' }}
        env:
          ARM_PARAMETERS_FILE: .artifacts/infra/${{ env.HEAD_SHA }}/runtime.parameters.json
        run: |
          mkdir -p ".artifacts/infra/$HEAD_SHA"
          node scripts/pipeline/shared/render-infra-parameters.mjs

      - name: Validate infra template
        if: ${{ env.JOB_REQUIRED == 'true' }}
        run: |
          az deployment group validate \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "acceptance-$HEAD_SHA" \
            --template-file infra/azure/main.bicep \
            --parameters @".artifacts/infra/$HEAD_SHA/runtime.parameters.json" \
            --output json > ".artifacts/infra/$HEAD_SHA/validate.json"

      - name: Upload infra acceptance artifact
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: infra-readonly-acceptance-${{ env.HEAD_SHA }}
          path: .artifacts/infra/${{ env.HEAD_SHA }}
          if-no-files-found: warn

  identity_readonly_acceptance:
    name: identity-readonly-acceptance
    needs:
      - load_release_candidate
    if: ${{ always() && needs.load_release_candidate.result == 'success' }}
    runs-on: ubuntu-latest
    timeout-minutes: 30
    environment: acceptance
    outputs:
      identity_config_contract_status: ${{ steps.identity_config.outputs.config_contract_status }}
      identity_config_contract_reason_codes_json: ${{ steps.identity_config.outputs.config_contract_reason_codes_json }}
    env:
      HEAD_SHA: ${{ needs.load_release_candidate.outputs.head_sha }}
      ARM_USE_OIDC: "true"
      ARM_USE_AZUREAD: "true"
      ARM_CLIENT_ID: ${{ secrets.AZURE_ACCEPTANCE_IDENTITY_CLIENT_ID }}
      ARM_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
      TFSTATE_RESOURCE_GROUP: ${{ vars.TFSTATE_RESOURCE_GROUP }}
      TFSTATE_STORAGE_ACCOUNT: ${{ vars.TFSTATE_STORAGE_ACCOUNT }}
      TFSTATE_CONTAINER: ${{ vars.TFSTATE_CONTAINER }}
      TFSTATE_KEY: ${{ vars.TFSTATE_KEY }}
      API_IDENTIFIER_URI: ${{ vars.API_IDENTIFIER_URI }}
      IDENTITY_OWNER_OBJECT_IDS_JSON: ${{ vars.IDENTITY_OWNER_OBJECT_IDS_JSON }}
      ACA_WEB_CUSTOM_DOMAIN: ${{ vars.ACA_WEB_CUSTOM_DOMAIN }}
      GITHUB_ENVIRONMENT_NAME: production
      JOB_REQUIRED: ${{ needs.load_release_candidate.outputs.identity_changed == 'true' && needs.load_release_candidate.outputs.docs_only_changed != 'true' }}
    steps:
      - name: Record not-required identity acceptance
        if: ${{ env.JOB_REQUIRED != 'true' }}
        run: |
          set -euo pipefail
          mkdir -p ".artifacts/identity/$HEAD_SHA"
          cat > ".artifacts/identity/$HEAD_SHA/acceptance-not-required.json" <<JSON
          {
            "schemaVersion": "1",
            "generatedAt": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "headSha": "$HEAD_SHA",
            "status": "not-required",
            "reasonCode": "IDENTITY_READONLY_ACCEPTANCE_NOT_REQUIRED"
          }
          JSON

      - name: Checkout
        if: ${{ env.JOB_REQUIRED == 'true' }}
        uses: actions/checkout@v4

      - name: Setup Terraform
        if: ${{ env.JOB_REQUIRED == 'true' }}
        uses: hashicorp/setup-terraform@v3

      - name: Validate identity config contract
        if: ${{ env.JOB_REQUIRED == 'true' }}
        id: identity_config
        env:
          IDENTITY_CONFIG_MODE: acceptance
          REQUIRED_ENV_NAMES: ARM_CLIENT_ID,ARM_TENANT_ID,ARM_SUBSCRIPTION_ID,TFSTATE_RESOURCE_GROUP,TFSTATE_STORAGE_ACCOUNT,TFSTATE_CONTAINER,TFSTATE_KEY,IDENTITY_OWNER_OBJECT_IDS_JSON,ACA_WEB_CUSTOM_DOMAIN
        run: node scripts/pipeline/shared/validate-identity-config.mjs

      - name: Azure login (OIDC)
        if: ${{ env.JOB_REQUIRED == 'true' }}
        uses: azure/login@v2
        with:
          client-id: ${{ env.ARM_CLIENT_ID }}
          tenant-id: ${{ env.ARM_TENANT_ID }}
          allow-no-subscriptions: true

      - name: Terraform format check
        if: ${{ env.JOB_REQUIRED == 'true' }}
        run: terraform -chdir=infra/identity fmt -check -recursive

      - name: Terraform init
        if: ${{ env.JOB_REQUIRED == 'true' }}
        run: |
          terraform -chdir=infra/identity init \
            -input=false \
            -backend-config="resource_group_name=${TFSTATE_RESOURCE_GROUP}" \
            -backend-config="storage_account_name=${TFSTATE_STORAGE_ACCOUNT}" \
            -backend-config="container_name=${TFSTATE_CONTAINER}" \
            -backend-config="key=${TFSTATE_KEY}" \
            -backend-config="use_oidc=true" \
            -backend-config="use_azuread_auth=true" \
            -backend-config="tenant_id=${ARM_TENANT_ID}" \
            -backend-config="subscription_id=${ARM_SUBSCRIPTION_ID}" \
            -backend-config="client_id=${ARM_CLIENT_ID}"

      - name: Terraform validate
        if: ${{ env.JOB_REQUIRED == 'true' }}
        run: terraform -chdir=infra/identity validate

      - name: Terraform plan
        if: ${{ env.JOB_REQUIRED == 'true' }}
        env:
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          gh_organization="${GITHUB_REPOSITORY%%/*}"
          gh_repository="${GITHUB_REPOSITORY##*/}"
          mkdir -p ".artifacts/identity/$HEAD_SHA"
          terraform -chdir=infra/identity plan \
            -input=false \
            -lock=false \
            -var-file=env/prod.tfvars \
            -var "github_organization=${gh_organization}" \
            -var "github_repository=${gh_repository}" \
            -var "github_environment_name=${GITHUB_ENVIRONMENT_NAME}" \
            -var "api_identifier_uri=${{ steps.identity_config.outputs.api_identifier_uri }}" \
            -var "owners=${IDENTITY_OWNER_OBJECT_IDS_JSON}" \
            -var "web_custom_domain=${ACA_WEB_CUSTOM_DOMAIN}" \
            -out=tfplan
          terraform -chdir=infra/identity show -json tfplan > ".artifacts/identity/$HEAD_SHA/plan.json"

      - name: Upload identity acceptance artifact
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: identity-readonly-acceptance-${{ env.HEAD_SHA }}
          path: |
            .artifacts/identity/${{ env.HEAD_SHA }}/plan.json
            .artifacts/identity/${{ env.HEAD_SHA }}/config-validation.json
          if-no-files-found: warn

  automated_acceptance_test_gate:
    name: automated-acceptance-test-gate
    needs:
      - load_release_candidate
      - runtime_api_system_acceptance
      - runtime_browser_acceptance
      - runtime_migration_image_acceptance
      - infra_readonly_acceptance
      - identity_readonly_acceptance
    if: ${{ always() && needs.load_release_candidate.result == 'success' }}
    runs-on: ubuntu-latest
    timeout-minutes: 20
    outputs:
      acceptance_decision: ${{ steps.finalize.outputs.acceptance_decision }}
      deployment_required: ${{ steps.scope.outputs.deployment_required }}
      deployment_pipeline_config_required: ${{ steps.scope.outputs.deployment_pipeline_config_required }}
      deploy_skip_reason_code: ${{ steps.scope.outputs.deploy_skip_reason_code }}
      reason_codes_json: ${{ steps.finalize.outputs.reason_codes_json }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: Resolve acceptance scope
        id: scope
        env:
          STAGE_ELIGIBILITY_MODE: acceptance
          CHANGE_CLASS: ${{ needs.load_release_candidate.outputs.change_class }}
          INFRA_CHANGED: ${{ needs.load_release_candidate.outputs.infra_changed }}
          IDENTITY_CHANGED: ${{ needs.load_release_candidate.outputs.identity_changed }}
          DOCS_ONLY_CHANGED: ${{ needs.load_release_candidate.outputs.docs_only_changed }}
          REQUIRES_INFRA_CONVERGENCE: ${{ needs.load_release_candidate.outputs.requires_infra_convergence }}
        run: node scripts/pipeline/shared/resolve-stage-eligibility.mjs

      - name: Decide automated acceptance test gate
        id: decide
        if: ${{ steps.scope.outputs.deployment_required == 'true' }}
        continue-on-error: true
        env:
          HEAD_SHA: ${{ needs.load_release_candidate.outputs.head_sha }}
          RUNTIME_REQUIRED: ${{ needs.load_release_candidate.outputs.runtime_changed }}
          INFRA_REQUIRED: ${{ needs.load_release_candidate.outputs.infra_changed == 'true' || needs.load_release_candidate.outputs.requires_infra_convergence == 'true' }}
          IDENTITY_REQUIRED: ${{ needs.load_release_candidate.outputs.identity_changed }}
          RELEASE_CANDIDATE_API_REF: ${{ needs.load_release_candidate.outputs.release_candidate_api_ref }}
          RELEASE_CANDIDATE_WEB_REF: ${{ needs.load_release_candidate.outputs.release_candidate_web_ref }}
          RELEASE_CANDIDATE_REF_CONTRACT_STATUS: ${{ needs.load_release_candidate.outputs.release_candidate_ref_contract_status }}
          RELEASE_CANDIDATE_REF_CONTRACT_REASON_CODES_JSON: ${{ needs.load_release_candidate.outputs.release_candidate_ref_contract_reason_codes_json }}
          IDENTITY_CONFIG_CONTRACT_STATUS: ${{ needs.identity_readonly_acceptance.outputs.identity_config_contract_status }}
          IDENTITY_CONFIG_CONTRACT_REASON_CODES_JSON: ${{ needs.identity_readonly_acceptance.outputs.identity_config_contract_reason_codes_json }}
          CHECK_RESULTS_JSON: ${{ format('{{"load-release-candidate":"{0}","runtime-api-system-acceptance":"{1}","runtime-browser-acceptance":"{2}","runtime-migration-image-acceptance":"{3}","infra-readonly-acceptance":"{4}","identity-readonly-acceptance":"{5}"}}', needs.load_release_candidate.result, needs.runtime_api_system_acceptance.result, needs.runtime_browser_acceptance.result, needs.runtime_migration_image_acceptance.result, needs.infra_readonly_acceptance.result, needs.identity_readonly_acceptance.result) }}
        run: node scripts/pipeline/cloud/automated-acceptance-test-gate/decide-automated-acceptance-test-gate.mjs

      - name: Finalize acceptance decision
        id: finalize
        env:
          DEPLOYMENT_REQUIRED: ${{ steps.scope.outputs.deployment_required }}
          DEPLOY_SKIP_REASON_CODE: ${{ steps.scope.outputs.deploy_skip_reason_code }}
          HEAD_SHA: ${{ needs.load_release_candidate.outputs.head_sha }}
          DECIDE_OUTCOME: ${{ steps.decide.outcome }}
        run: node scripts/pipeline/cloud/automated-acceptance-test-gate/finalize-automated-acceptance-test-gate.mjs

      - name: Upload acceptance artifacts
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: automated-acceptance-test-gate-${{ needs.load_release_candidate.outputs.head_sha }}
          path: .artifacts/automated-acceptance-test-gate/${{ needs.load_release_candidate.outputs.head_sha }}/result.json
          if-no-files-found: error

      - name: Fail acceptance on NO
        if: ${{ steps.finalize.outputs.acceptance_decision == 'NO' }}
        run: |
          echo "Automated acceptance test gate decision is NO" >&2
          exit 1

  deploy_identity:
    name: deploy-identity
    needs:
      - load_release_candidate
      - automated_acceptance_test_gate
    if: ${{ always() && needs.load_release_candidate.result == 'success' && needs.automated_acceptance_test_gate.result == 'success' && needs.automated_acceptance_test_gate.outputs.acceptance_decision == 'YES' && needs.automated_acceptance_test_gate.outputs.deployment_required == 'true' && needs.load_release_candidate.outputs.identity_changed == 'true' }}
    runs-on: ubuntu-latest
    environment: production
    timeout-minutes: 45
    concurrency:
      group: production-identity-mutation
      cancel-in-progress: false
    env:
      HEAD_SHA: ${{ needs.load_release_candidate.outputs.head_sha }}
      API_IDENTIFIER_URI: ${{ vars.API_IDENTIFIER_URI }}
      ARM_CLIENT_ID: ${{ secrets.AZURE_IDENTITY_CLIENT_ID }}
      ARM_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
      TFSTATE_RESOURCE_GROUP: ${{ vars.TFSTATE_RESOURCE_GROUP }}
      TFSTATE_STORAGE_ACCOUNT: ${{ vars.TFSTATE_STORAGE_ACCOUNT }}
      TFSTATE_CONTAINER: ${{ vars.TFSTATE_CONTAINER }}
      TFSTATE_KEY: ${{ vars.TFSTATE_KEY }}
      IDENTITY_OWNER_OBJECT_IDS_JSON: ${{ vars.IDENTITY_OWNER_OBJECT_IDS_JSON }}
      ACA_WEB_CUSTOM_DOMAIN: ${{ vars.ACA_WEB_CUSTOM_DOMAIN }}
      GITHUB_ENVIRONMENT_NAME: production
      GITHUB_REPOSITORY: ${{ github.repository }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Validate identity config contract
        id: identity_config
        env:
          IDENTITY_CONFIG_MODE: production
          REQUIRED_ENV_NAMES: ARM_CLIENT_ID,ARM_TENANT_ID,ARM_SUBSCRIPTION_ID,TFSTATE_RESOURCE_GROUP,TFSTATE_STORAGE_ACCOUNT,TFSTATE_CONTAINER,TFSTATE_KEY,IDENTITY_OWNER_OBJECT_IDS_JSON,ACA_WEB_CUSTOM_DOMAIN
        run: node scripts/pipeline/shared/validate-identity-config.mjs

      - name: Azure login for identity apply
        uses: azure/login@v2
        with:
          client-id: ${{ env.ARM_CLIENT_ID }}
          tenant-id: ${{ env.ARM_TENANT_ID }}
          allow-no-subscriptions: true

      - name: Apply identity infrastructure
        env:
          ARM_USE_OIDC: "true"
          ARM_USE_AZUREAD: "true"
        run: |
          set -euo pipefail

          gh_organization="${GITHUB_REPOSITORY%%/*}"
          gh_repository="${GITHUB_REPOSITORY##*/}"

          terraform -chdir=infra/identity init \
            -input=false \
            -backend-config="resource_group_name=${TFSTATE_RESOURCE_GROUP}" \
            -backend-config="storage_account_name=${TFSTATE_STORAGE_ACCOUNT}" \
            -backend-config="container_name=${TFSTATE_CONTAINER}" \
            -backend-config="key=${TFSTATE_KEY}" \
            -backend-config="use_oidc=true" \
            -backend-config="use_azuread_auth=true" \
            -backend-config="tenant_id=${ARM_TENANT_ID}" \
            -backend-config="subscription_id=${ARM_SUBSCRIPTION_ID}" \
            -backend-config="client_id=${ARM_CLIENT_ID}"

          terraform -chdir=infra/identity apply \
            -input=false \
            -auto-approve \
            -var-file=env/prod.tfvars \
            -var "github_organization=${gh_organization}" \
            -var "github_repository=${gh_repository}" \
            -var "github_environment_name=${GITHUB_ENVIRONMENT_NAME}" \
            -var "api_identifier_uri=${{ steps.identity_config.outputs.api_identifier_uri }}" \
            -var "owners=${IDENTITY_OWNER_OBJECT_IDS_JSON}" \
            -var "web_custom_domain=${ACA_WEB_CUSTOM_DOMAIN}"

          mkdir -p ".artifacts/identity/$HEAD_SHA"
          terraform -chdir=infra/identity output -json > ".artifacts/identity/$HEAD_SHA/outputs.json"

      - name: Upload identity mutation artifact
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: deploy-identity-${{ env.HEAD_SHA }}
          path: .artifacts/identity/${{ env.HEAD_SHA }}
          if-no-files-found: warn

  deploy_infra:
    name: deploy-infra
    needs:
      - load_release_candidate
      - automated_acceptance_test_gate
    if: ${{ always() && needs.load_release_candidate.result == 'success' && needs.automated_acceptance_test_gate.result == 'success' && needs.automated_acceptance_test_gate.outputs.acceptance_decision == 'YES' && needs.automated_acceptance_test_gate.outputs.deployment_required == 'true' && (needs.load_release_candidate.outputs.infra_changed == 'true' || needs.load_release_candidate.outputs.requires_infra_convergence == 'true' || needs.load_release_candidate.outputs.runtime_changed == 'true') }}
    runs-on: ubuntu-latest
    environment: production
    timeout-minutes: 60
    concurrency:
      group: production-azure-mutation
      cancel-in-progress: false
    outputs:
      infra_apply_required: ${{ steps.decide_infra_apply.outputs.infra_apply_required }}
      api_prod_url: ${{ steps.current_state.outputs.api_prod_url }}
      web_prod_url: ${{ steps.current_state.outputs.web_prod_url }}
      codex_prod_url: ${{ steps.current_state.outputs.codex_prod_url }}
    env:
      HEAD_SHA: ${{ needs.load_release_candidate.outputs.head_sha }}
      RUNTIME_CHANGED: ${{ needs.load_release_candidate.outputs.runtime_changed }}
      INFRA_CHANGED: ${{ needs.load_release_candidate.outputs.infra_changed }}
      REQUIRES_INFRA_CONVERGENCE: ${{ needs.load_release_candidate.outputs.requires_infra_convergence }}
      RELEASE_CANDIDATE_API_REF: ${{ needs.load_release_candidate.outputs.release_candidate_api_ref }}
      RELEASE_CANDIDATE_WEB_REF: ${{ needs.load_release_candidate.outputs.release_candidate_web_ref }}
      RELEASE_CANDIDATE_WORKER_REF: ${{ needs.load_release_candidate.outputs.release_candidate_worker_ref }}
      RELEASE_CANDIDATE_CODEX_REF: ${{ needs.load_release_candidate.outputs.release_candidate_codex_ref }}
      AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}
      AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
      AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
      AZURE_LOCATION: ${{ vars.AZURE_LOCATION }}
      AZURE_VNET_NAME: ${{ vars.AZURE_VNET_NAME }}
      AZURE_ACA_SUBNET_NAME: ${{ vars.AZURE_ACA_SUBNET_NAME }}
      AZURE_POSTGRES_SUBNET_NAME: ${{ vars.AZURE_POSTGRES_SUBNET_NAME }}
      AZURE_PRIVATE_DNS_ZONE_NAME: ${{ vars.AZURE_PRIVATE_DNS_ZONE_NAME }}
      ACA_ENVIRONMENT_NAME: ${{ vars.ACA_ENVIRONMENT_NAME }}
      AZURE_LOG_ANALYTICS_WORKSPACE_NAME: ${{ vars.AZURE_LOG_ANALYTICS_WORKSPACE_NAME }}
      ACA_API_APP_NAME: ${{ vars.ACA_API_APP_NAME }}
      ACA_WEB_APP_NAME: ${{ vars.ACA_WEB_APP_NAME }}
      ACA_WORKER_APP_NAME: ${{ vars.ACA_WORKER_APP_NAME }}
      ACA_CODEX_APP_NAME: ${{ vars.ACA_CODEX_APP_NAME }}
      ACA_MIGRATE_JOB_NAME: ${{ vars.ACA_MIGRATE_JOB_NAME }}
      ACA_API_CUSTOM_DOMAIN: ${{ vars.ACA_API_CUSTOM_DOMAIN }}
      ACA_WEB_CUSTOM_DOMAIN: ${{ vars.ACA_WEB_CUSTOM_DOMAIN }}
      ACA_CODEX_CUSTOM_DOMAIN: ${{ vars.ACA_CODEX_CUSTOM_DOMAIN }}
      ACR_PULL_IDENTITY_NAME: ${{ vars.ACR_PULL_IDENTITY_NAME }}
      ACR_NAME: ${{ vars.ACR_NAME }}
      POSTGRES_SERVER_NAME: ${{ vars.POSTGRES_SERVER_NAME }}
      POSTGRES_DATABASE_NAME: ${{ vars.POSTGRES_DATABASE_NAME }}
      POSTGRES_ADMIN_USERNAME: ${{ vars.POSTGRES_ADMIN_USERNAME }}
      WEB_SESSION_SECRET: ${{ secrets.WEB_SESSION_SECRET }}
      ENTRA_LOGIN_ENABLED: ${{ vars.ENTRA_LOGIN_ENABLED }}
      ENTRA_CLIENT_ID: ${{ vars.ENTRA_CLIENT_ID }}
      ENTRA_CLIENT_SECRET: ${{ secrets.ENTRA_CLIENT_SECRET }}
      ENTRA_ALLOWED_TENANT_IDS: ${{ vars.ENTRA_ALLOWED_TENANT_IDS }}
      AUTH_DEV_FALLBACK_ENABLED: ${{ vars.AUTH_DEV_FALLBACK_ENABLED }}
      API_IDENTIFIER_URI: ${{ vars.API_IDENTIFIER_URI }}
      AUTH_AUDIENCE: ${{ vars.AUTH_AUDIENCE }}
      AUTH_ALLOWED_CLIENT_IDS: ${{ vars.AUTH_ALLOWED_CLIENT_IDS }}
      AUTH_ACTIVE_TENANT_IDS: ${{ vars.AUTH_ACTIVE_TENANT_IDS }}
      OAUTH_TOKEN_ISSUER: ${{ vars.OAUTH_TOKEN_ISSUER }}
      OAUTH_TOKEN_AUDIENCE: ${{ vars.OAUTH_TOKEN_AUDIENCE }}
      OAUTH_TOKEN_SIGNING_SECRET: ${{ secrets.OAUTH_TOKEN_SIGNING_SECRET }}
      AUTH_BOOTSTRAP_ALLOWED_TENANT_ID: ${{ vars.API_SMOKE_ALLOWED_TENANT_ID }}
      AUTH_BOOTSTRAP_ALLOWED_APP_CLIENT_ID: ${{ secrets.API_SMOKE_ALLOWED_CLIENT_ID }}
      AUTH_BOOTSTRAP_DELEGATED_USER_OID: ${{ vars.AUTH_BOOTSTRAP_DELEGATED_USER_OID }}
      AUTH_BOOTSTRAP_DELEGATED_USER_EMAIL: ${{ vars.AUTH_BOOTSTRAP_DELEGATED_USER_EMAIL }}
      WORKER_RUNTIME_IDENTITY_NAME: ${{ vars.WORKER_RUNTIME_IDENTITY_NAME }}
      SERVICE_BUS_PROD_NAMESPACE_NAME: ${{ vars.SERVICE_BUS_PROD_NAMESPACE_NAME }}
      SERVICE_BUS_ACCEPTANCE_NAMESPACE_NAME: ${{ vars.SERVICE_BUS_ACCEPTANCE_NAMESPACE_NAME }}
      SERVICE_BUS_QUEUE_NAME: ${{ vars.SERVICE_BUS_QUEUE_NAME }}
      WORKER_RUN_MODE: ${{ vars.WORKER_RUN_MODE }}
      POSTGRES_ADMIN_PASSWORD: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
      ACR_REGISTRY: ${{ format('{0}.azurecr.io', vars.ACR_NAME) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_DEPLOY_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Validate deployment release candidate refs
        run: |
          set -euo pipefail

          for image in "$RELEASE_CANDIDATE_API_REF" "$RELEASE_CANDIDATE_WEB_REF" "$RELEASE_CANDIDATE_WORKER_REF" "$RELEASE_CANDIDATE_CODEX_REF"; do
            if [ -z "$image" ]; then
              echo "Release candidate image reference is missing for infra deployment" >&2
              exit 1
            fi
            if [[ "$image" != "${ACR_REGISTRY}/"*"@sha256:"* ]]; then
              echo "Release candidate ref must be an ACR digest ref: $image" >&2
              exit 1
            fi
          done

      - name: Resolve Codex app name
        if: ${{ env.RUNTIME_CHANGED == 'true' }}
        run: |
          set -euo pipefail

          codex_app_name="${ACA_CODEX_APP_NAME:-}"
          if [ -z "$codex_app_name" ]; then
            if [[ "$ACA_API_APP_NAME" == *"-api-"* ]]; then
              codex_app_name="${ACA_API_APP_NAME/-api-/-codex-}"
            else
              echo "ACA_CODEX_APP_NAME is empty and fallback from ACA_API_APP_NAME failed" >&2
              exit 1
            fi
          fi

          echo "ACA_CODEX_APP_NAME=$codex_app_name" >> "$GITHUB_ENV"

      - name: Check Codex app presence
        id: codex_app_presence
        if: ${{ env.RUNTIME_CHANGED == 'true' }}
        run: |
          set -euo pipefail

          if ! az containerapp show \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$ACA_CODEX_APP_NAME" \
            --query id \
            --output tsv >/dev/null 2>&1; then
            echo "codex_app_exists=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          codex_identity_type="$(az containerapp show \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$ACA_CODEX_APP_NAME" \
            --query 'identity.type' \
            --output tsv)"
          codex_registry_identity="$(az containerapp show \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$ACA_CODEX_APP_NAME" \
            --query 'properties.configuration.registries[0].identity' \
            --output tsv)"
          codex_registry_server="$(az containerapp show \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$ACA_CODEX_APP_NAME" \
            --query 'properties.configuration.registries[0].server' \
            --output tsv)"

          if [ "$codex_identity_type" != "UserAssigned" ] || [ -z "$codex_registry_identity" ] || [ "$codex_registry_server" != "$ACR_REGISTRY" ] || [[ "$codex_registry_identity" != *"/$ACR_PULL_IDENTITY_NAME" ]]; then
            echo "Codex app exists but registry identity config is not converged. Forcing infra convergence."
            echo "codex_app_exists=false" >> "$GITHUB_OUTPUT"
          else
            echo "codex_app_exists=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Check Worker app presence
        id: worker_app_presence
        if: ${{ env.RUNTIME_CHANGED == 'true' }}
        run: |
          set -euo pipefail

          if ! az containerapp show \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$ACA_WORKER_APP_NAME" \
            --query id \
            --output tsv >/dev/null 2>&1; then
            echo "worker_app_exists=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          worker_identity_type="$(az containerapp show \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$ACA_WORKER_APP_NAME" \
            --query 'identity.type' \
            --output tsv)"
          worker_registry_identity="$(az containerapp show \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$ACA_WORKER_APP_NAME" \
            --query 'properties.configuration.registries[0].identity' \
            --output tsv)"
          worker_registry_server="$(az containerapp show \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$ACA_WORKER_APP_NAME" \
            --query 'properties.configuration.registries[0].server' \
            --output tsv)"

          if [ "$worker_identity_type" != "UserAssigned" ] || [ -z "$worker_registry_identity" ] || [ "$worker_registry_server" != "$ACR_REGISTRY" ] || [[ "$worker_registry_identity" != *"/$ACR_PULL_IDENTITY_NAME" ]]; then
            echo "Worker app exists but registry identity config is not converged. Forcing infra convergence."
            echo "worker_app_exists=false" >> "$GITHUB_OUTPUT"
          else
            echo "worker_app_exists=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Decide infra apply necessity
        id: decide_infra_apply
        run: |
          set -euo pipefail

          infra_apply_required="false"
          if [ "$INFRA_CHANGED" = "true" ] || [ "$REQUIRES_INFRA_CONVERGENCE" = "true" ]; then
            infra_apply_required="true"
          elif [ "$RUNTIME_CHANGED" = "true" ] && { [ "${{ steps.codex_app_presence.outputs.codex_app_exists }}" != "true" ] || [ "${{ steps.worker_app_presence.outputs.worker_app_exists }}" != "true" ]; }; then
            infra_apply_required="true"
          fi

          echo "infra_apply_required=$infra_apply_required" >> "$GITHUB_OUTPUT"

      - name: Apply infra (when needed)
        if: ${{ steps.decide_infra_apply.outputs.infra_apply_required == 'true' }}
        env:
          API_IMAGE: ${{ env.RELEASE_CANDIDATE_API_REF }}
          WEB_IMAGE: ${{ env.RELEASE_CANDIDATE_WEB_REF }}
          WORKER_IMAGE: ${{ env.RELEASE_CANDIDATE_WORKER_REF }}
          CODEX_IMAGE: ${{ env.RELEASE_CANDIDATE_CODEX_REF }}
          ARM_PARAMETERS_FILE: .artifacts/infra/${{ env.HEAD_SHA }}/runtime.parameters.json
        run: |
          set -euo pipefail

          mkdir -p ".artifacts/infra/$HEAD_SHA"
          node scripts/pipeline/shared/render-infra-parameters.mjs

          export ARM_TEMPLATE_FILE="infra/azure/main.bicep"
          export ARM_ARTIFACT_DIR=".artifacts/infra/$HEAD_SHA"

          node scripts/pipeline/cloud/deployment-stage/apply-infra.mjs

      - name: Verify worker Service Bus cutover
        if: ${{ steps.decide_infra_apply.outputs.infra_apply_required == 'true' }}
        run: node scripts/pipeline/cloud/deployment-stage/verify-worker-servicebus-cutover.mjs

      - name: Resolve current production URLs
        id: current_state
        run: |
          set -euo pipefail

          api_prod_url="https://$(az containerapp show --resource-group "$AZURE_RESOURCE_GROUP" --name "$ACA_API_APP_NAME" --query 'properties.configuration.ingress.fqdn' --output tsv)"
          web_prod_url="https://$(az containerapp show --resource-group "$AZURE_RESOURCE_GROUP" --name "$ACA_WEB_APP_NAME" --query 'properties.configuration.ingress.fqdn' --output tsv)"
          codex_prod_url="https://$(az containerapp show --resource-group "$AZURE_RESOURCE_GROUP" --name "$ACA_CODEX_APP_NAME" --query 'properties.configuration.ingress.fqdn' --output tsv)"

          echo "api_prod_url=$api_prod_url" >> "$GITHUB_OUTPUT"
          echo "web_prod_url=$web_prod_url" >> "$GITHUB_OUTPUT"
          echo "codex_prod_url=$codex_prod_url" >> "$GITHUB_OUTPUT"

      - name: Upload infra mutation artifacts
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: deploy-infra-${{ env.HEAD_SHA }}
          path: .artifacts/infra/${{ env.HEAD_SHA }}
          if-no-files-found: warn

  deploy_runtime:
    name: deploy-runtime
    needs:
      - load_release_candidate
      - automated_acceptance_test_gate
      - deploy_infra
    if: ${{ always() && needs.load_release_candidate.result == 'success' && needs.automated_acceptance_test_gate.result == 'success' && needs.automated_acceptance_test_gate.outputs.acceptance_decision == 'YES' && needs.automated_acceptance_test_gate.outputs.deployment_required == 'true' && needs.load_release_candidate.outputs.runtime_changed == 'true' && (needs.deploy_infra.result == 'success' || needs.deploy_infra.result == 'skipped') }}
    runs-on: ubuntu-latest
    environment: production
    timeout-minutes: 45
    concurrency:
      group: production-azure-mutation
      cancel-in-progress: false
    outputs:
      api_prod_url: ${{ steps.current_state.outputs.api_prod_url }}
      web_prod_url: ${{ steps.current_state.outputs.web_prod_url }}
      codex_prod_url: ${{ steps.current_state.outputs.codex_prod_url }}
    env:
      HEAD_SHA: ${{ needs.load_release_candidate.outputs.head_sha }}
      REQUIRES_MIGRATIONS: ${{ needs.load_release_candidate.outputs.requires_migrations }}
      RELEASE_CANDIDATE_API_REF: ${{ needs.load_release_candidate.outputs.release_candidate_api_ref }}
      RELEASE_CANDIDATE_WEB_REF: ${{ needs.load_release_candidate.outputs.release_candidate_web_ref }}
      RELEASE_CANDIDATE_WORKER_REF: ${{ needs.load_release_candidate.outputs.release_candidate_worker_ref }}
      RELEASE_CANDIDATE_CODEX_REF: ${{ needs.load_release_candidate.outputs.release_candidate_codex_ref }}
      AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
      ACA_API_APP_NAME: ${{ vars.ACA_API_APP_NAME }}
      ACA_WEB_APP_NAME: ${{ vars.ACA_WEB_APP_NAME }}
      ACA_WORKER_APP_NAME: ${{ vars.ACA_WORKER_APP_NAME }}
      ACA_CODEX_APP_NAME: ${{ vars.ACA_CODEX_APP_NAME }}
      ACA_MIGRATE_JOB_NAME: ${{ vars.ACA_MIGRATE_JOB_NAME }}
      ACR_NAME: ${{ vars.ACR_NAME }}
      ACR_PULL_IDENTITY_NAME: ${{ vars.ACR_PULL_IDENTITY_NAME }}
      ACR_REGISTRY: ${{ format('{0}.azurecr.io', vars.ACR_NAME) }}
      MIGRATION_TIMEOUT_SECONDS: ${{ vars.MIGRATION_TIMEOUT_SECONDS || '900' }}
      MIGRATION_CONTAINER_NAME: ${{ vars.MIGRATION_CONTAINER_NAME || 'migrate' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_DEPLOY_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Validate deployment release candidate refs
        run: |
          set -euo pipefail

          for image in "$RELEASE_CANDIDATE_API_REF" "$RELEASE_CANDIDATE_WEB_REF" "$RELEASE_CANDIDATE_WORKER_REF" "$RELEASE_CANDIDATE_CODEX_REF"; do
            if [ -z "$image" ]; then
              echo "Release candidate image reference is missing for runtime deployment" >&2
              exit 1
            fi
            if [[ "$image" != "${ACR_REGISTRY}/"*"@sha256:"* ]]; then
              echo "Release candidate ref must be an ACR digest ref: $image" >&2
              exit 1
            fi
          done

      - name: Resolve Codex app name
        run: |
          set -euo pipefail

          codex_app_name="${ACA_CODEX_APP_NAME:-}"
          if [ -z "$codex_app_name" ]; then
            if [[ "$ACA_API_APP_NAME" == *"-api-"* ]]; then
              codex_app_name="${ACA_API_APP_NAME/-api-/-codex-}"
            else
              echo "ACA_CODEX_APP_NAME is empty and fallback from ACA_API_APP_NAME failed" >&2
              exit 1
            fi
          fi

          echo "ACA_CODEX_APP_NAME=$codex_app_name" >> "$GITHUB_ENV"

      - name: Update migration job image
        run: |
          az containerapp job update \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$ACA_MIGRATE_JOB_NAME" \
            --image "$RELEASE_CANDIDATE_API_REF" \
            --output none

      - name: Run migration job
        if: ${{ env.REQUIRES_MIGRATIONS == 'true' }}
        id: migration_start
        env:
          AZURE_RESOURCE_GROUP: ${{ env.AZURE_RESOURCE_GROUP }}
          ACA_MIGRATE_JOB_NAME: ${{ env.ACA_MIGRATE_JOB_NAME }}
        run: node scripts/pipeline/cloud/deployment-stage/start-migration-job.mjs

      - name: Wait for migration completion
        if: ${{ env.REQUIRES_MIGRATIONS == 'true' }}
        env:
          AZURE_RESOURCE_GROUP: ${{ env.AZURE_RESOURCE_GROUP }}
          ACA_MIGRATE_JOB_NAME: ${{ env.ACA_MIGRATE_JOB_NAME }}
          MIGRATION_EXECUTION_NAME: ${{ steps.migration_start.outputs.migration_execution_name }}
          MIGRATION_TIMEOUT_SECONDS: ${{ env.MIGRATION_TIMEOUT_SECONDS }}
          MIGRATION_CONTAINER_NAME: ${{ env.MIGRATION_CONTAINER_NAME }}
        run: node scripts/pipeline/cloud/deployment-stage/wait-migration-job.mjs

      - name: Deploy API
        uses: azure/container-apps-deploy-action@v1
        with:
          imageToDeploy: ${{ env.RELEASE_CANDIDATE_API_REF }}
          containerAppName: ${{ env.ACA_API_APP_NAME }}
          resourceGroup: ${{ env.AZURE_RESOURCE_GROUP }}
          disableTelemetry: true

      - name: Deploy Web
        uses: azure/container-apps-deploy-action@v1
        with:
          imageToDeploy: ${{ env.RELEASE_CANDIDATE_WEB_REF }}
          containerAppName: ${{ env.ACA_WEB_APP_NAME }}
          resourceGroup: ${{ env.AZURE_RESOURCE_GROUP }}
          disableTelemetry: true

      - name: Deploy Worker
        uses: azure/container-apps-deploy-action@v1
        with:
          imageToDeploy: ${{ env.RELEASE_CANDIDATE_WORKER_REF }}
          containerAppName: ${{ env.ACA_WORKER_APP_NAME }}
          resourceGroup: ${{ env.AZURE_RESOURCE_GROUP }}
          disableTelemetry: true

      - name: Deploy Codex
        uses: azure/container-apps-deploy-action@v1
        with:
          imageToDeploy: ${{ env.RELEASE_CANDIDATE_CODEX_REF }}
          containerAppName: ${{ env.ACA_CODEX_APP_NAME }}
          resourceGroup: ${{ env.AZURE_RESOURCE_GROUP }}
          disableTelemetry: true

      - name: Resolve current production URLs
        id: current_state
        run: |
          set -euo pipefail

          api_prod_url="https://$(az containerapp show --resource-group "$AZURE_RESOURCE_GROUP" --name "$ACA_API_APP_NAME" --query 'properties.configuration.ingress.fqdn' --output tsv)"
          web_prod_url="https://$(az containerapp show --resource-group "$AZURE_RESOURCE_GROUP" --name "$ACA_WEB_APP_NAME" --query 'properties.configuration.ingress.fqdn' --output tsv)"
          codex_prod_url="https://$(az containerapp show --resource-group "$AZURE_RESOURCE_GROUP" --name "$ACA_CODEX_APP_NAME" --query 'properties.configuration.ingress.fqdn' --output tsv)"

          echo "api_prod_url=$api_prod_url" >> "$GITHUB_OUTPUT"
          echo "web_prod_url=$web_prod_url" >> "$GITHUB_OUTPUT"
          echo "codex_prod_url=$codex_prod_url" >> "$GITHUB_OUTPUT"

      - name: Upload runtime mutation artifacts
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: deploy-runtime-${{ env.HEAD_SHA }}
          path: .artifacts/deploy/${{ env.HEAD_SHA }}
          if-no-files-found: warn

  deploy_release_candidate:
    name: deploy-release-candidate
    needs:
      - load_release_candidate
      - automated_acceptance_test_gate
      - deploy_identity
      - deploy_infra
      - deploy_runtime
    if: ${{ always() && needs.load_release_candidate.result == 'success' && needs.automated_acceptance_test_gate.result == 'success' && needs.automated_acceptance_test_gate.outputs.acceptance_decision == 'YES' && needs.automated_acceptance_test_gate.outputs.deployment_required == 'true' && (needs.deploy_identity.result == 'success' || needs.deploy_identity.result == 'skipped') && (needs.deploy_infra.result == 'success' || needs.deploy_infra.result == 'skipped') && (needs.deploy_runtime.result == 'success' || needs.deploy_runtime.result == 'skipped') }}
    runs-on: ubuntu-latest
    environment: production
    timeout-minutes: 20
    outputs:
      api_prod_url: ${{ steps.current_state.outputs.api_prod_url }}
      web_prod_url: ${{ steps.current_state.outputs.web_prod_url }}
      codex_prod_url: ${{ steps.current_state.outputs.codex_prod_url }}
      deployment_id: ${{ steps.record_release.outputs.deployment_id }}
    env:
      HEAD_SHA: ${{ needs.load_release_candidate.outputs.head_sha }}
      CHANGE_CLASS: ${{ needs.load_release_candidate.outputs.change_class }}
      RELEASE_CANDIDATE_API_REF: ${{ needs.load_release_candidate.outputs.release_candidate_api_ref }}
      RELEASE_CANDIDATE_WEB_REF: ${{ needs.load_release_candidate.outputs.release_candidate_web_ref }}
      RELEASE_CANDIDATE_WORKER_REF: ${{ needs.load_release_candidate.outputs.release_candidate_worker_ref }}
      RELEASE_CANDIDATE_CODEX_REF: ${{ needs.load_release_candidate.outputs.release_candidate_codex_ref }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Resolve final production URLs
        id: current_state
        run: |
          set -euo pipefail

          api_prod_url="${{ needs.deploy_runtime.outputs.api_prod_url }}"
          web_prod_url="${{ needs.deploy_runtime.outputs.web_prod_url }}"
          codex_prod_url="${{ needs.deploy_runtime.outputs.codex_prod_url }}"

          if [ -z "$api_prod_url" ]; then
            api_prod_url="${{ needs.deploy_infra.outputs.api_prod_url }}"
          fi
          if [ -z "$web_prod_url" ]; then
            web_prod_url="${{ needs.deploy_infra.outputs.web_prod_url }}"
          fi
          if [ -z "$codex_prod_url" ]; then
            codex_prod_url="${{ needs.deploy_infra.outputs.codex_prod_url }}"
          fi

          echo "api_prod_url=$api_prod_url" >> "$GITHUB_OUTPUT"
          echo "web_prod_url=$web_prod_url" >> "$GITHUB_OUTPUT"
          echo "codex_prod_url=$codex_prod_url" >> "$GITHUB_OUTPUT"

      - name: Record successful production deployment
        id: record_release
        if: ${{ success() }}
        env:
          GITHUB_TOKEN: ${{ github.token }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          TARGET_ENVIRONMENT: production
          HEAD_SHA: ${{ env.HEAD_SHA }}
          DEPLOY_LOG_URL: ${{ format('{0}/{1}/actions/runs/{2}', github.server_url, github.repository, github.run_id) }}
          DEPLOY_ENVIRONMENT_URL: ${{ steps.current_state.outputs.web_prod_url }}
          RELEASE_CANDIDATE_API_REF: ${{ env.RELEASE_CANDIDATE_API_REF }}
          RELEASE_CANDIDATE_WEB_REF: ${{ env.RELEASE_CANDIDATE_WEB_REF }}
          RELEASE_CANDIDATE_WORKER_REF: ${{ env.RELEASE_CANDIDATE_WORKER_REF }}
          RELEASE_CANDIDATE_CODEX_REF: ${{ env.RELEASE_CANDIDATE_CODEX_REF }}
          CHANGE_CLASS: ${{ env.CHANGE_CLASS }}
        run: node scripts/pipeline/cloud/deployment-stage/record-release.mjs

      - name: Write deployment record artifact
        if: ${{ always() }}
        run: |
          mkdir -p ".artifacts/deployment-stage/$HEAD_SHA"
          cat > ".artifacts/deployment-stage/$HEAD_SHA/deployment-record.json" <<JSON
          {
            "schemaVersion": "1",
            "generatedAt": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "headSha": "$HEAD_SHA",
            "changeClass": "$CHANGE_CLASS",
            "deploymentId": "${{ steps.record_release.outputs.deployment_id || '' }}",
            "releaseCandidate": {
              "api": "$RELEASE_CANDIDATE_API_REF",
              "web": "$RELEASE_CANDIDATE_WEB_REF",
              "worker": "$RELEASE_CANDIDATE_WORKER_REF",
              "codex": "$RELEASE_CANDIDATE_CODEX_REF"
            }
          }
          JSON

      - name: Upload mutation artifacts
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: deploy-release-candidate-${{ env.HEAD_SHA }}
          path: |
            .artifacts/deployment-stage/${{ env.HEAD_SHA }}/deployment-record.json
            .artifacts/deploy/${{ env.HEAD_SHA }}
            .artifacts/infra/${{ env.HEAD_SHA }}
            .artifacts/identity/${{ env.HEAD_SHA }}
          if-no-files-found: warn

  production_blackbox_verify:
    name: production-blackbox-verify
    needs:
      - load_release_candidate
      - automated_acceptance_test_gate
      - deploy_identity
      - deploy_infra
      - deploy_runtime
      - deploy_release_candidate
    if: ${{ always() && needs.deploy_release_candidate.result == 'success' && needs.automated_acceptance_test_gate.outputs.acceptance_decision == 'YES' && needs.automated_acceptance_test_gate.outputs.deployment_required == 'true' && (needs.load_release_candidate.outputs.runtime_changed == 'true' || needs.load_release_candidate.outputs.infra_changed == 'true' || needs.load_release_candidate.outputs.requires_infra_convergence == 'true') }}
    runs-on: ubuntu-latest
    environment: production
    timeout-minutes: 30
    env:
      HEAD_SHA: ${{ needs.load_release_candidate.outputs.head_sha }}
      TARGET_API_BASE_URL: ${{ needs.deploy_release_candidate.outputs.api_prod_url }}
      WEB_BASE_URL: ${{ needs.deploy_release_candidate.outputs.web_prod_url }}
      EXPECTED_ENTRYPOINT: /
      REQUIRED_FLOW_IDS_JSON: '["compass-smoke"]'
      API_SMOKE_ALLOWED_TENANT_ID: ${{ vars.API_SMOKE_ALLOWED_TENANT_ID }}
      API_SMOKE_ALLOWED_CLIENT_ID: ${{ secrets.API_SMOKE_ALLOWED_CLIENT_ID }}
      API_SMOKE_ALLOWED_CLIENT_SECRET: ${{ secrets.API_SMOKE_ALLOWED_CLIENT_SECRET }}
      API_IDENTIFIER_URI: ${{ vars.API_IDENTIFIER_URI }}
      API_SMOKE_DENIED_TENANT_ID: ${{ vars.API_SMOKE_DENIED_TENANT_ID }}
      API_SMOKE_DENIED_CLIENT_ID: ${{ secrets.API_SMOKE_DENIED_CLIENT_ID }}
      API_SMOKE_DENIED_CLIENT_SECRET: ${{ secrets.API_SMOKE_DENIED_CLIENT_SECRET }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node + pnpm
        uses: ./.github/actions/setup-node-pnpm

      - name: API smoke verification
        run: node scripts/pipeline/cloud/deployment-stage/verify-api-smoke.mjs

      - name: Install Playwright browser
        run: pnpm exec playwright install --with-deps chromium

      - name: Browser smoke verification
        env:
          PR_NUMBER: 0
        run: pnpm test:acceptance:browser

      - name: Upload post-deployment verification artifacts
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: production-blackbox-verify-${{ env.HEAD_SHA }}
          path: |
            .artifacts/deploy/${{ env.HEAD_SHA }}/api-smoke.json
            .artifacts/browser-evidence/${{ env.HEAD_SHA }}
          if-no-files-found: warn

  deployment_stage:
    name: deployment-stage
    needs:
      - load_release_candidate
      - automated_acceptance_test_gate
      - deploy_release_candidate
      - production_blackbox_verify
    if: ${{ always() && needs.load_release_candidate.result == 'success' }}
    runs-on: ubuntu-latest
    outputs:
      production_decision: ${{ steps.result.outputs.production_decision }}
      reason_codes_json: ${{ steps.result.outputs.reason_codes_json }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: Write deployment stage result
        id: result
        env:
          HEAD_SHA: ${{ needs.load_release_candidate.outputs.head_sha }}
          ACCEPTANCE_DECISION: ${{ needs.automated_acceptance_test_gate.outputs.acceptance_decision }}
          ACCEPTANCE_REASON_CODES_JSON: ${{ needs.automated_acceptance_test_gate.outputs.reason_codes_json }}
          DEPLOYMENT_REQUIRED: ${{ needs.automated_acceptance_test_gate.outputs.deployment_required }}
          RUNTIME_CHANGED: ${{ needs.load_release_candidate.outputs.runtime_changed }}
          DESKTOP_CHANGED: ${{ needs.load_release_candidate.outputs.desktop_changed }}
          INFRA_CHANGED: ${{ needs.load_release_candidate.outputs.infra_changed }}
          IDENTITY_CHANGED: ${{ needs.load_release_candidate.outputs.identity_changed }}
          REQUIRES_INFRA_CONVERGENCE: ${{ needs.load_release_candidate.outputs.requires_infra_convergence }}
          CHANGE_CLASS: ${{ needs.load_release_candidate.outputs.change_class }}
          RELEASE_CANDIDATE_API_REF: ${{ needs.load_release_candidate.outputs.release_candidate_api_ref }}
          RELEASE_CANDIDATE_WEB_REF: ${{ needs.load_release_candidate.outputs.release_candidate_web_ref }}
          RELEASE_CANDIDATE_WORKER_REF: ${{ needs.load_release_candidate.outputs.release_candidate_worker_ref }}
          RELEASE_CANDIDATE_CODEX_REF: ${{ needs.load_release_candidate.outputs.release_candidate_codex_ref }}
          DEPLOY_RESULT: ${{ needs.deploy_release_candidate.result }}
          VERIFY_RESULT: ${{ needs.production_blackbox_verify.result }}
          DEPLOYMENT_ID: ${{ needs.deploy_release_candidate.outputs.deployment_id }}
        run: node scripts/pipeline/cloud/deployment-stage/decide-deployment-stage.mjs

      - name: Upload production result artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployment-stage-${{ needs.load_release_candidate.outputs.head_sha }}
          path: .artifacts/deployment-stage/${{ needs.load_release_candidate.outputs.head_sha }}
          if-no-files-found: warn

  release_decision:
    name: release-decision
    needs:
      - verify_integration_gate_evidence
      - determine_scope
      - load_release_candidate
      - automated_acceptance_test_gate
      - deployment_stage
    if: ${{ always() }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: Collect cloud deployment pipeline stage timing
        env:
          GITHUB_TOKEN: ${{ github.token }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          HEAD_SHA: ${{ needs.load_release_candidate.outputs.head_sha || github.sha }}
        run: node scripts/pipeline/shared/collect-cloud-deployment-stage-timing.mjs

      - name: Upload cloud deployment timing artifact
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: cloud-deployment-pipeline-timing-${{ needs.load_release_candidate.outputs.head_sha || github.sha }}
          path: .artifacts/pipeline/${{ needs.load_release_candidate.outputs.head_sha || github.sha }}/timing.json
          if-no-files-found: warn

      - name: Write release decision artifact
        env:
          RELEASE_CANDIDATE_SHA: ${{ needs.load_release_candidate.outputs.head_sha || github.sha }}
          REPLAY_MODE: "false"
          COMMIT_STAGE_RESULT: ${{ needs.verify_integration_gate_evidence.result }}
          LOAD_RELEASE_CANDIDATE_RESULT: ${{ needs.load_release_candidate.result }}
          AUTOMATED_ACCEPTANCE_TEST_GATE_RESULT: ${{ needs.automated_acceptance_test_gate.result }}
          DEPLOYMENT_STAGE_RESULT: ${{ needs.deployment_stage.result }}
          HEAD_SHA: ${{ needs.load_release_candidate.outputs.head_sha || github.sha }}
          ACCEPTANCE_DECISION: ${{ needs.automated_acceptance_test_gate.outputs.acceptance_decision || '' }}
          ACCEPTANCE_REASON_CODES_JSON: ${{ needs.automated_acceptance_test_gate.outputs.reason_codes_json || '[]' }}
          PRODUCTION_DECISION: ${{ needs.deployment_stage.outputs.production_decision || '' }}
          PRODUCTION_REASON_CODES_JSON: ${{ needs.deployment_stage.outputs.reason_codes_json || '[]' }}
          DEPLOYMENT_REQUIRED: ${{ needs.automated_acceptance_test_gate.outputs.deployment_required || '' }}
          RELEASE_CANDIDATE_API_REF: ${{ needs.load_release_candidate.outputs.release_candidate_api_ref }}
          RELEASE_CANDIDATE_WEB_REF: ${{ needs.load_release_candidate.outputs.release_candidate_web_ref }}
          RELEASE_CANDIDATE_WORKER_REF: ${{ needs.load_release_candidate.outputs.release_candidate_worker_ref }}
          RELEASE_CANDIDATE_CODEX_REF: ${{ needs.load_release_candidate.outputs.release_candidate_codex_ref }}
        run: node scripts/pipeline/shared/decide-release-outcome.mjs

      - name: Upload release decision artifact
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: release-decision-${{ needs.load_release_candidate.outputs.head_sha || github.sha }}
          path: .artifacts/release/${{ needs.load_release_candidate.outputs.head_sha || github.sha }}/decision.json
          if-no-files-found: warn
