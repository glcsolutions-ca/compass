name: Deploy to Azure Container Apps

on:
  push:
    branches:
      - main

permissions:
  contents: read
  id-token: write

concurrency:
  group: deploy-main
  cancel-in-progress: false

jobs:
  deploy:
    name: deploy-production
    environment: production
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      HEAD_SHA: ${{ github.sha }}
      RISK_TIER: t3
      ACR_NAME: ${{ vars.ACR_NAME }}
      ACR_REGISTRY: ${{ format('{0}.azurecr.io', vars.ACR_NAME) }}
      AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
      ACA_API_APP_NAME: ${{ vars.ACA_API_APP_NAME }}
      ACA_WEB_APP_NAME: ${{ vars.ACA_WEB_APP_NAME }}
      ACA_MIGRATE_JOB_NAME: ${{ vars.ACA_MIGRATE_JOB_NAME }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Guard stale main SHA (early)
        run: node scripts/deploy/assert-current-main-sha.mjs

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.30.1

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc
          cache: pnpm
          cache-dependency-path: pnpm-lock.yaml

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Azure login (deploy identity)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_DEPLOY_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Ensure Azure CLI extensions
        run: az extension add --name containerapp --upgrade --only-show-errors

      - name: Verify required resources exist
        run: |
          set -euo pipefail

          missing=()

          if ! az containerapp show \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$ACA_API_APP_NAME" \
            --query name \
            --output tsv >/dev/null 2>&1; then
            missing+=("container app: $ACA_API_APP_NAME")
          fi

          if ! az containerapp show \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$ACA_WEB_APP_NAME" \
            --query name \
            --output tsv >/dev/null 2>&1; then
            missing+=("container app: $ACA_WEB_APP_NAME")
          fi

          if ! az containerapp job show \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$ACA_MIGRATE_JOB_NAME" \
            --query name \
            --output tsv >/dev/null 2>&1; then
            missing+=("container app job: $ACA_MIGRATE_JOB_NAME")
          fi

          if [ "${#missing[@]}" -gt 0 ]; then
            printf 'Missing required infra resources in %s:\n' "$AZURE_RESOURCE_GROUP" >&2
            for item in "${missing[@]}"; do
              printf ' - %s\n' "$item" >&2
            done
            echo "Run .github/workflows/infra-apply.yml on main, then rerun deploy." >&2
            exit 1
          fi

      - name: Login to ACR
        run: az acr login --name "$ACR_NAME" --only-show-errors

      - name: Build and push API image to ACR
        id: api_image
        run: |
          set -euo pipefail

          api_image="$ACR_REGISTRY/compass-api:$HEAD_SHA"

          docker build -f apps/api/Dockerfile -t "$api_image" .
          docker push "$api_image"

          api_digest=$(docker inspect --format='{{index .RepoDigests 0}}' "$api_image" || true)

          echo "api_image=$api_image" >> "$GITHUB_OUTPUT"
          echo "api_digest=$api_digest" >> "$GITHUB_OUTPUT"

      - name: Build and push Web image to ACR
        id: web_image
        run: |
          set -euo pipefail

          web_image="$ACR_REGISTRY/compass-web:$HEAD_SHA"

          docker build -f apps/web/Dockerfile -t "$web_image" .
          docker push "$web_image"

          web_digest=$(docker inspect --format='{{index .RepoDigests 0}}' "$web_image" || true)

          echo "web_image=$web_image" >> "$GITHUB_OUTPUT"
          echo "web_digest=$web_digest" >> "$GITHUB_OUTPUT"

      - name: Update migration job image
        run: |
          az containerapp job update \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$ACA_MIGRATE_JOB_NAME" \
            --image "${{ steps.api_image.outputs.api_image }}" \
            --output none

      - name: Run migration job
        id: migration_start
        env:
          AZURE_RESOURCE_GROUP: ${{ env.AZURE_RESOURCE_GROUP }}
          ACA_MIGRATE_JOB_NAME: ${{ env.ACA_MIGRATE_JOB_NAME }}
        run: node scripts/deploy/start-migration-job.mjs

      - name: Wait for migration completion
        id: migration_wait
        env:
          AZURE_RESOURCE_GROUP: ${{ env.AZURE_RESOURCE_GROUP }}
          ACA_MIGRATE_JOB_NAME: ${{ env.ACA_MIGRATE_JOB_NAME }}
          MIGRATION_EXECUTION_NAME: ${{ steps.migration_start.outputs.migration_execution_name }}
          MIGRATION_TIMEOUT_SECONDS: 900
        run: node scripts/deploy/wait-migration-job.mjs

      - name: Guard stale main SHA (pre-rollout)
        run: node scripts/deploy/assert-current-main-sha.mjs

      - name: Deploy API via ACA deploy action
        uses: azure/container-apps-deploy-action@v1
        with:
          imageToDeploy: ${{ steps.api_image.outputs.api_image }}
          containerAppName: ${{ env.ACA_API_APP_NAME }}
          resourceGroup: ${{ env.AZURE_RESOURCE_GROUP }}
          disableTelemetry: true

      - name: Deploy Web via ACA deploy action
        uses: azure/container-apps-deploy-action@v1
        with:
          imageToDeploy: ${{ steps.web_image.outputs.web_image }}
          containerAppName: ${{ env.ACA_WEB_APP_NAME }}
          resourceGroup: ${{ env.AZURE_RESOURCE_GROUP }}
          disableTelemetry: true

      - name: Resolve production URLs
        id: prod_urls
        run: |
          set -euo pipefail

          api_fqdn=$(az containerapp show \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$ACA_API_APP_NAME" \
            --query properties.configuration.ingress.fqdn \
            --output tsv)

          web_fqdn=$(az containerapp show \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$ACA_WEB_APP_NAME" \
            --query properties.configuration.ingress.fqdn \
            --output tsv)

          if [ -z "$api_fqdn" ] || [ -z "$web_fqdn" ]; then
            echo "Failed to resolve production ingress FQDNs." >&2
            exit 1
          fi

          echo "api_prod_url=https://$api_fqdn" >> "$GITHUB_OUTPUT"
          echo "web_prod_url=https://$web_fqdn" >> "$GITHUB_OUTPUT"

      - name: Assert single-revision and scale drift policy
        run: |
          set -euo pipefail

          for app in "$ACA_API_APP_NAME" "$ACA_WEB_APP_NAME"; do
            converged="false"

            for attempt in {1..12}; do
              app_json=$(az containerapp show \
                --resource-group "$AZURE_RESOURCE_GROUP" \
                --name "$app" \
                --output json)

              revisions_json=$(az containerapp revision list \
                --resource-group "$AZURE_RESOURCE_GROUP" \
                --name "$app" \
                --output json)

              mode=$(jq -r '.properties.configuration.activeRevisionsMode // ""' <<<"$app_json")
              normalized_mode=$(echo "$mode" | tr '[:upper:]' '[:lower:]')

              min_replicas=$(jq -r '.properties.template.scale.minReplicas // 0' <<<"$app_json")
              max_replicas=$(jq -r '.properties.template.scale.maxReplicas // 0' <<<"$app_json")
              cpu=$(jq -r '.properties.template.containers[0].resources.cpu // ""' <<<"$app_json")
              memory=$(jq -r '.properties.template.containers[0].resources.memory // ""' <<<"$app_json")
              max_inactive_revisions=$(jq -r '.properties.configuration.maxInactiveRevisions // ""' <<<"$app_json")
              latest_revision=$(jq -r '.properties.latestRevisionName // ""' <<<"$app_json")

              active_count=$(jq '[.[] | select(.properties.active == true)] | length' <<<"$revisions_json")
              active_revision=$(jq -r '[.[] | select(.properties.active == true)][0].name // ""' <<<"$revisions_json")

              if [ "$normalized_mode" != "single" ]; then
                echo "$app is not in single revision mode (actual: $mode)" >&2
                exit 1
              fi

              if [ "${min_replicas:-0}" != "0" ]; then
                echo "$app minReplicas drifted (actual: ${min_replicas:-unset})" >&2
                exit 1
              fi

              if [ "${max_replicas:-0}" != "1" ]; then
                echo "$app maxReplicas drifted (actual: ${max_replicas:-unset})" >&2
                exit 1
              fi

              if [ "${cpu:-unset}" != "0.25" ]; then
                echo "$app cpu drifted (actual: ${cpu:-unset})" >&2
                exit 1
              fi

              if [ "${memory:-unset}" != "0.5Gi" ]; then
                echo "$app memory drifted (actual: ${memory:-unset})" >&2
                exit 1
              fi

              if [ -n "${max_inactive_revisions:-}" ] && ! [[ "${max_inactive_revisions}" =~ ^[0-9]+$ ]]; then
                echo "$app maxInactiveRevisions is not numeric (actual: ${max_inactive_revisions:-unset})" >&2
                exit 1
              fi

              if [ -n "${max_inactive_revisions:-}" ] && [ "${max_inactive_revisions}" -gt 2 ]; then
                echo "$app maxInactiveRevisions drifted (actual: ${max_inactive_revisions:-unset})" >&2
                exit 1
              fi

              if [ "${active_count:-0}" = "1" ] && [ -n "$latest_revision" ] && [ "$active_revision" = "$latest_revision" ]; then
                converged="true"
                break
              fi

              echo "$app active revision count=${active_count:-0}, latestRevision=$latest_revision, activeRevision=$active_revision; waiting for single-revision convergence (attempt $attempt/12)"
              sleep 10
            done

            if [ "$converged" != "true" ]; then
              echo "$app did not converge to latest revision as single active revision within 120 seconds" >&2
              exit 1
            fi
          done

      - name: Azure login (smoke identity)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_SMOKE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          allow-no-subscriptions: true

      - name: Acquire Entra smoke token
        id: token
        run: |
          audience="${{ vars.ENTRA_AUDIENCE }}"
          if [[ "$audience" == */.default ]]; then
            scope="$audience"
          else
            scope="$audience/.default"
          fi

          smoke_token=$(az account get-access-token --scope "$scope" --query accessToken -o tsv)
          echo "::add-mask::$smoke_token"
          echo "smoke_token=$smoke_token" >> "$GITHUB_OUTPUT"

      - name: API smoke verification
        env:
          TARGET_API_BASE_URL: ${{ steps.prod_urls.outputs.api_prod_url }}
          ACCESS_TOKEN: ${{ steps.token.outputs.smoke_token }}
          EXPECTED_EMPLOYEE_ID: ${{ vars.SMOKE_EXPECTED_ACCOUNT_IDENTITY }}
          REQUIRE_EMPLOYEE_FOUND: ${{ vars.SMOKE_REQUIRE_EMPLOYEE_FOUND }}
        run: node scripts/deploy/verify-api-smoke.mjs

      - name: Install Playwright browser
        run: pnpm exec playwright install --with-deps chromium

      - name: Browser evidence
        env:
          HEAD_SHA: ${{ env.HEAD_SHA }}
          PR_NUMBER: 0
          RISK_TIER: t3
          WEB_BASE_URL: ${{ steps.prod_urls.outputs.web_prod_url }}
          BROWSER_SMOKE_BEARER_TOKEN: ${{ steps.token.outputs.smoke_token }}
          BROWSER_SMOKE_PAYLOAD_TIMEOUT_MS: "45000"
          EXPECTED_ENTRYPOINT: /
          EXPECTED_ACCOUNT_IDENTITY_RAW: ${{ vars.SMOKE_EXPECTED_ACCOUNT_IDENTITY }}
          REQUIRED_FLOW_IDS_JSON: '["compass-smoke"]'
        run: |
          expected_identity="$EXPECTED_ACCOUNT_IDENTITY_RAW"
          if [ -z "$expected_identity" ]; then
            expected_identity="employee-123"
          fi
          EXPECTED_ACCOUNT_IDENTITY="$expected_identity" pnpm ci:browser-evidence

      - name: Write final deploy result artifact
        if: ${{ always() }}
        env:
          JOB_STATUS: ${{ job.status }}
          API_IMAGE: ${{ steps.api_image.outputs.api_image }}
          WEB_IMAGE: ${{ steps.web_image.outputs.web_image }}
          MIGRATE_IMAGE: ${{ steps.api_image.outputs.api_image }}
          MIGRATE_DIGEST: ${{ steps.api_image.outputs.api_digest }}
          API_PROD_URL: ${{ steps.prod_urls.outputs.api_prod_url }}
          WEB_PROD_URL: ${{ steps.prod_urls.outputs.web_prod_url }}
        run: |
          mkdir -p ".artifacts/deploy/$HEAD_SHA"
          cat > ".artifacts/deploy/$HEAD_SHA/result.json" <<JSON
          {
            "schemaVersion": "1",
            "generatedAt": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "headSha": "$HEAD_SHA",
            "tier": "$RISK_TIER",
            "status": "${JOB_STATUS:-unknown}",
            "images": {
              "api": "$API_IMAGE",
              "web": "$WEB_IMAGE",
              "migrate": "$MIGRATE_IMAGE",
              "migrateDigest": "$MIGRATE_DIGEST"
            },
            "urls": {
              "api": "$API_PROD_URL",
              "web": "$WEB_PROD_URL"
            }
          }
          JSON

      - name: Upload deploy artifacts
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: deploy-${{ env.HEAD_SHA }}
          path: .artifacts/deploy/${{ env.HEAD_SHA }}
          if-no-files-found: warn

      - name: Upload browser evidence artifact
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: browser-evidence-${{ env.HEAD_SHA }}
          path: .artifacts/browser-evidence/${{ env.HEAD_SHA }}
          if-no-files-found: warn
