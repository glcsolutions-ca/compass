name: Release Candidate (main)

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read
  id-token: write
  deployments: write

jobs:
  classify:
    name: classify
    runs-on: ubuntu-latest
    outputs:
      base_sha: ${{ steps.classify.outputs.base_sha }}
      base_source: ${{ steps.resolve_base.outputs.base_source }}
      base_deployment_id: ${{ steps.resolve_base.outputs.base_deployment_id }}
      kind: ${{ steps.classify.outputs.kind }}
      rollout: ${{ steps.classify.outputs.rollout }}
      needs_infra: ${{ steps.classify.outputs.needs_infra }}
      needs_migrations: ${{ steps.classify.outputs.needs_migrations }}
      changed_files_json: ${{ steps.classify.outputs.changed_files_json }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve base SHA from production deployment record
        id: resolve_base
        env:
          GITHUB_TOKEN: ${{ github.token }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          HEAD_SHA: ${{ github.sha }}
          TARGET_ENVIRONMENT: production
          FALLBACK_BASE_SHA: ${{ github.event.before }}
        run: node scripts/deploy/get-last-prod-deployment-sha.mjs

      - name: Classify release kind
        id: classify
        env:
          BASE_SHA: ${{ steps.resolve_base.outputs.base_sha }}
          HEAD_SHA: ${{ github.sha }}
        run: node scripts/ci/release-classify.mjs

  checks:
    name: checks
    needs: classify
    if: ${{ needs.classify.outputs.kind == 'checks' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.30.1

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc
          cache: pnpm
          cache-dependency-path: pnpm-lock.yaml

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Check format
        run: pnpm check:format

      - name: Check merge-contract tests
        run: pnpm test:merge-contract

  promote:
    name: promote
    needs: classify
    if: ${{ needs.classify.outputs.kind != 'checks' }}
    runs-on: ubuntu-latest
    environment: production
    timeout-minutes: 60
    concurrency:
      group: prod-main
      cancel-in-progress: false
    env:
      HEAD_SHA: ${{ github.sha }}
      BASE_SHA: ${{ needs.classify.outputs.base_sha }}
      BASE_SOURCE: ${{ needs.classify.outputs.base_source }}
      BASE_DEPLOYMENT_ID: ${{ needs.classify.outputs.base_deployment_id }}
      RISK_TIER: high
      KIND: ${{ needs.classify.outputs.kind }}
      ROLLOUT: ${{ needs.classify.outputs.rollout }}
      NEEDS_INFRA: ${{ needs.classify.outputs.needs_infra }}
      NEEDS_MIGRATIONS: ${{ needs.classify.outputs.needs_migrations }}
      ACR_NAME: ${{ vars.ACR_NAME }}
      ACR_REGISTRY: ${{ format('{0}.azurecr.io', vars.ACR_NAME) }}
      AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
      AZURE_LOCATION: ${{ vars.AZURE_LOCATION }}
      AZURE_VNET_NAME: ${{ vars.AZURE_VNET_NAME }}
      AZURE_ACA_SUBNET_NAME: ${{ vars.AZURE_ACA_SUBNET_NAME }}
      AZURE_POSTGRES_SUBNET_NAME: ${{ vars.AZURE_POSTGRES_SUBNET_NAME }}
      AZURE_PRIVATE_DNS_ZONE_NAME: ${{ vars.AZURE_PRIVATE_DNS_ZONE_NAME }}
      ACA_ENVIRONMENT_NAME: ${{ vars.ACA_ENVIRONMENT_NAME }}
      AZURE_LOG_ANALYTICS_WORKSPACE_NAME: ${{ vars.AZURE_LOG_ANALYTICS_WORKSPACE_NAME }}
      ACA_API_APP_NAME: ${{ vars.ACA_API_APP_NAME }}
      ACA_WEB_APP_NAME: ${{ vars.ACA_WEB_APP_NAME }}
      ACA_API_CUSTOM_DOMAIN: ${{ vars.ACA_API_CUSTOM_DOMAIN }}
      ACA_WEB_CUSTOM_DOMAIN: ${{ vars.ACA_WEB_CUSTOM_DOMAIN }}
      ACA_API_MANAGED_CERTIFICATE_NAME: ${{ vars.ACA_API_MANAGED_CERTIFICATE_NAME }}
      ACA_WEB_MANAGED_CERTIFICATE_NAME: ${{ vars.ACA_WEB_MANAGED_CERTIFICATE_NAME }}
      ACA_CUSTOM_DOMAIN_VALIDATION_METHOD: ${{ vars.ACA_CUSTOM_DOMAIN_VALIDATION_METHOD }}
      ACA_MIGRATE_JOB_NAME: ${{ vars.ACA_MIGRATE_JOB_NAME }}
      ACR_PULL_IDENTITY_NAME: ${{ vars.ACR_PULL_IDENTITY_NAME }}
      ACR_SKU: ${{ vars.ACR_SKU }}
      POSTGRES_SERVER_NAME: ${{ vars.POSTGRES_SERVER_NAME }}
      POSTGRES_DATABASE_NAME: ${{ vars.POSTGRES_DATABASE_NAME }}
      POSTGRES_ADMIN_USERNAME: ${{ vars.POSTGRES_ADMIN_USERNAME }}
      POSTGRES_VERSION: ${{ vars.POSTGRES_VERSION }}
      POSTGRES_SKU_NAME: ${{ vars.POSTGRES_SKU_NAME }}
      POSTGRES_SKU_TIER: ${{ vars.POSTGRES_SKU_TIER }}
      POSTGRES_STORAGE_MB: ${{ vars.POSTGRES_STORAGE_MB }}
    outputs:
      stale_preinfra: ${{ steps.stale_preinfra.outputs.is_stale || 'false' }}
      stale_preboundary: ${{ steps.stale_preboundary.outputs.is_stale || 'false' }}
      current_api_ref: ${{ steps.current_state.outputs.current_api_ref }}
      current_web_ref: ${{ steps.current_state.outputs.current_web_ref }}
      candidate_api_ref: ${{ steps.candidate_refs.outputs.candidate_api_ref }}
      candidate_web_ref: ${{ steps.candidate_refs.outputs.candidate_web_ref }}
      api_prod_url: ${{ steps.current_state.outputs.api_prod_url }}
      web_prod_url: ${{ steps.current_state.outputs.web_prod_url }}
      new_deployment_id: ${{ steps.record_production_deployment.outputs.deployment_id }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.30.1

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc
          cache: pnpm
          cache-dependency-path: pnpm-lock.yaml

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Stale guard before infra boundary
        id: stale_preinfra
        run: |
          set +e
          node scripts/deploy/assert-current-main-sha.mjs
          code=$?
          if [ "$code" -eq 0 ]; then
            echo "is_stale=false" >> "$GITHUB_OUTPUT"
          else
            echo "is_stale=true" >> "$GITHUB_OUTPUT"
            echo "Stale candidate before infra boundary; skipping promotion steps."
          fi
          exit 0

      - name: Azure login (deploy identity)
        if: ${{ steps.stale_preinfra.outputs.is_stale != 'true' }}
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_DEPLOY_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Ensure Azure CLI extensions
        if: ${{ steps.stale_preinfra.outputs.is_stale != 'true' }}
        run: az extension add --name containerapp --upgrade --only-show-errors

      - name: Verify required resources exist
        if: ${{ steps.stale_preinfra.outputs.is_stale != 'true' }}
        run: |
          set -euo pipefail

          missing=()

          if ! az containerapp show \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$ACA_API_APP_NAME" \
            --query name \
            --output tsv >/dev/null 2>&1; then
            missing+=("container app: $ACA_API_APP_NAME")
          fi

          if ! az containerapp show \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$ACA_WEB_APP_NAME" \
            --query name \
            --output tsv >/dev/null 2>&1; then
            missing+=("container app: $ACA_WEB_APP_NAME")
          fi

          if ! az containerapp job show \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$ACA_MIGRATE_JOB_NAME" \
            --query name \
            --output tsv >/dev/null 2>&1; then
            missing+=("container app job: $ACA_MIGRATE_JOB_NAME")
          fi

          if [ "${#missing[@]}" -gt 0 ]; then
            printf 'Missing required infra resources in %s:\n' "$AZURE_RESOURCE_GROUP" >&2
            for item in "${missing[@]}"; do
              printf ' - %s\n' "$item" >&2
            done
            echo "Run .github/workflows/infra-apply.yml, then rerun release." >&2
            exit 1
          fi

      - name: Resolve current refs and production URLs
        id: current_state
        if: ${{ steps.stale_preinfra.outputs.is_stale != 'true' }}
        run: |
          set -euo pipefail

          normalize_image_ref() {
            local image="$1"

            if [[ "$image" != "$ACR_REGISTRY/"* ]]; then
              echo "Image is not in expected ACR registry: $image" >&2
              return 1
            fi

            local repo_ref="${image#"$ACR_REGISTRY/"}"
            local repo
            local digest

            if [[ "$repo_ref" == *@sha256:* ]]; then
              repo="${repo_ref%%@*}"
              digest="${repo_ref#*@}"
              local resolved_digest
              resolved_digest="$(az acr repository show \
                --name "$ACR_NAME" \
                --image "$repo@$digest" \
                --query digest \
                --output tsv 2>/dev/null || true)"

              if [ -z "$resolved_digest" ]; then
                echo "Image digest was not found in ACR: $image" >&2
                return 1
              fi

              echo "$ACR_REGISTRY/$repo@$resolved_digest"
              return
            fi

            repo="${repo_ref%%:*}"
            digest="$(az acr repository show \
              --name "$ACR_NAME" \
              --image "$repo_ref" \
              --query digest \
              --output tsv 2>/dev/null || true)"

            if [ -z "$digest" ]; then
              echo "Image tag was not found in ACR: $image" >&2
              return 1
            fi

            echo "$ACR_REGISTRY/$repo@$digest"
          }

          api_image="$(az containerapp show \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$ACA_API_APP_NAME" \
            --query 'properties.template.containers[0].image' \
            --output tsv)"

          web_image="$(az containerapp show \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$ACA_WEB_APP_NAME" \
            --query 'properties.template.containers[0].image' \
            --output tsv)"

          api_ref="$(normalize_image_ref "$api_image")"
          web_ref="$(normalize_image_ref "$web_image")"

          api_fqdn="$(az containerapp show \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$ACA_API_APP_NAME" \
            --query properties.configuration.ingress.fqdn \
            --output tsv)"

          web_fqdn="$(az containerapp show \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$ACA_WEB_APP_NAME" \
            --query properties.configuration.ingress.fqdn \
            --output tsv)"

          if [ -z "$api_fqdn" ] || [ -z "$web_fqdn" ]; then
            echo "Failed to resolve production ingress FQDNs." >&2
            exit 1
          fi

          api_prod_url="https://$api_fqdn"
          if [ -n "${ACA_API_CUSTOM_DOMAIN:-}" ]; then
            api_custom_domain_bound_count="$(az containerapp hostname list \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --name "$ACA_API_APP_NAME" \
              --query "[?name=='${ACA_API_CUSTOM_DOMAIN}' && bindingType=='SniEnabled'] | length(@)" \
              --output tsv)"
            if [ "$api_custom_domain_bound_count" = "1" ]; then
              api_prod_url="https://${ACA_API_CUSTOM_DOMAIN}"
            fi
          fi

          web_prod_url="https://$web_fqdn"
          if [ -n "${ACA_WEB_CUSTOM_DOMAIN:-}" ]; then
            web_custom_domain_bound_count="$(az containerapp hostname list \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --name "$ACA_WEB_APP_NAME" \
              --query "[?name=='${ACA_WEB_CUSTOM_DOMAIN}' && bindingType=='SniEnabled'] | length(@)" \
              --output tsv)"
            if [ "$web_custom_domain_bound_count" = "1" ]; then
              web_prod_url="https://${ACA_WEB_CUSTOM_DOMAIN}"
            fi
          fi

          {
            echo "current_api_ref=$api_ref"
            echo "current_web_ref=$web_ref"
            echo "api_prod_url=$api_prod_url"
            echo "web_prod_url=$web_prod_url"
          } >> "$GITHUB_OUTPUT"

      - name: Validate managed certificate contract
        id: managed_certificate_contract
        if: ${{ steps.stale_preinfra.outputs.is_stale != 'true' && (env.KIND == 'infra' || env.NEEDS_INFRA == 'true') }}
        run: node scripts/deploy/assert-managed-certificate-contract.mjs

      - name: Apply infra updates
        if: ${{ steps.stale_preinfra.outputs.is_stale != 'true' && (env.KIND == 'infra' || env.NEEDS_INFRA == 'true') }}
        env:
          POSTGRES_ADMIN_PASSWORD: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
          API_IMAGE: ${{ steps.current_state.outputs.current_api_ref }}
          WEB_IMAGE: ${{ steps.current_state.outputs.current_web_ref }}
          ACA_API_CUSTOM_DOMAIN: ${{ vars.ACA_API_CUSTOM_DOMAIN }}
          ACA_WEB_CUSTOM_DOMAIN: ${{ vars.ACA_WEB_CUSTOM_DOMAIN }}
          ACA_API_MANAGED_CERTIFICATE_NAME: ${{ steps.managed_certificate_contract.outputs.api_managed_certificate_name }}
          ACA_WEB_MANAGED_CERTIFICATE_NAME: ${{ steps.managed_certificate_contract.outputs.web_managed_certificate_name }}
          ACA_CUSTOM_DOMAIN_VALIDATION_METHOD: ${{ vars.ACA_CUSTOM_DOMAIN_VALIDATION_METHOD }}
        run: |
          set -euo pipefail
          mkdir -p ".artifacts/infra/$HEAD_SHA"

          if [ -z "${POSTGRES_ADMIN_PASSWORD:-}" ]; then
            echo "Missing required GitHub environment secret: POSTGRES_ADMIN_PASSWORD" >&2
            exit 1
          fi

          custom_domain_validation_method="$(echo "${ACA_CUSTOM_DOMAIN_VALIDATION_METHOD:-CNAME}" | tr '[:lower:]' '[:upper:]')"
          case "$custom_domain_validation_method" in
            CNAME|HTTP|TXT) ;;
            *)
              echo "ACA_CUSTOM_DOMAIN_VALIDATION_METHOD must be one of CNAME, HTTP, TXT (actual: ${ACA_CUSTOM_DOMAIN_VALIDATION_METHOD:-<empty>})" >&2
              exit 1
              ;;
          esac

          providers=(
            "Microsoft.App"
            "Microsoft.ContainerService"
            "Microsoft.Network"
            "Microsoft.DBforPostgreSQL"
            "Microsoft.OperationalInsights"
          )
          for namespace in "${providers[@]}"; do
            state="$(az provider show --namespace "$namespace" --query registrationState -o tsv)"
            if [ "$state" != "Registered" ]; then
              az provider register --namespace "$namespace" --wait
            fi
          done

          arm_auth_status="$(az acr config authentication-as-arm show \
            --registry "$ACR_NAME" \
            --query status \
            --output tsv 2>/dev/null | tr '[:upper:]' '[:lower:]')"
          if [ "$arm_auth_status" != "enabled" ]; then
            az acr config authentication-as-arm update \
              --registry "$ACR_NAME" \
              --status enabled \
              --only-show-errors \
              --output none
          fi

          jq -n \
            --arg location "$AZURE_LOCATION" \
            --arg vnetName "$AZURE_VNET_NAME" \
            --arg acaSubnetName "$AZURE_ACA_SUBNET_NAME" \
            --arg postgresSubnetName "$AZURE_POSTGRES_SUBNET_NAME" \
            --arg privateDnsZoneName "$AZURE_PRIVATE_DNS_ZONE_NAME" \
            --arg environmentName "$ACA_ENVIRONMENT_NAME" \
            --arg logAnalyticsWorkspaceName "$AZURE_LOG_ANALYTICS_WORKSPACE_NAME" \
            --arg apiAppName "$ACA_API_APP_NAME" \
            --arg webAppName "$ACA_WEB_APP_NAME" \
            --arg apiCustomDomain "${ACA_API_CUSTOM_DOMAIN:-}" \
            --arg webCustomDomain "${ACA_WEB_CUSTOM_DOMAIN:-}" \
            --arg apiManagedCertificateName "${ACA_API_MANAGED_CERTIFICATE_NAME:-}" \
            --arg webManagedCertificateName "${ACA_WEB_MANAGED_CERTIFICATE_NAME:-}" \
            --arg customDomainValidationMethod "$custom_domain_validation_method" \
            --arg migrationJobName "$ACA_MIGRATE_JOB_NAME" \
            --arg acrPullIdentityName "$ACR_PULL_IDENTITY_NAME" \
            --arg acrName "$ACR_NAME" \
            --arg acrSku "$ACR_SKU" \
            --arg postgresServerName "$POSTGRES_SERVER_NAME" \
            --arg postgresDatabaseName "$POSTGRES_DATABASE_NAME" \
            --arg postgresAdminUsername "$POSTGRES_ADMIN_USERNAME" \
            --arg postgresVersion "$POSTGRES_VERSION" \
            --arg postgresSkuName "$POSTGRES_SKU_NAME" \
            --arg postgresSkuTier "$POSTGRES_SKU_TIER" \
            --arg postgresStorageMb "$POSTGRES_STORAGE_MB" \
            --arg postgresAdminPassword "$POSTGRES_ADMIN_PASSWORD" \
            --arg apiImage "$API_IMAGE" \
            --arg webImage "$WEB_IMAGE" \
            '{
              "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentParameters.json#",
              "contentVersion": "1.0.0.0",
              "parameters": {
                "location": {"value": $location},
                "vnetName": {"value": $vnetName},
                "acaSubnetName": {"value": $acaSubnetName},
                "postgresSubnetName": {"value": $postgresSubnetName},
                "privateDnsZoneName": {"value": $privateDnsZoneName},
                "environmentName": {"value": $environmentName},
                "logAnalyticsWorkspaceName": {"value": $logAnalyticsWorkspaceName},
                "apiAppName": {"value": $apiAppName},
                "webAppName": {"value": $webAppName},
                "apiCustomDomain": {"value": $apiCustomDomain},
                "webCustomDomain": {"value": $webCustomDomain},
                "apiManagedCertificateName": {"value": $apiManagedCertificateName},
                "webManagedCertificateName": {"value": $webManagedCertificateName},
                "customDomainValidationMethod": {"value": $customDomainValidationMethod},
                "migrationJobName": {"value": $migrationJobName},
                "acrPullIdentityName": {"value": $acrPullIdentityName},
                "acrName": {"value": $acrName},
                "acrSku": {"value": $acrSku},
                "postgresServerName": {"value": $postgresServerName},
                "postgresDatabaseName": {"value": $postgresDatabaseName},
                "postgresAdminUsername": {"value": $postgresAdminUsername},
                "postgresVersion": {"value": $postgresVersion},
                "postgresSkuName": {"value": $postgresSkuName},
                "postgresSkuTier": {"value": $postgresSkuTier},
                "postgresStorageMb": {"value": ($postgresStorageMb | tonumber)},
                "postgresAdminPassword": {"value": $postgresAdminPassword},
                "apiImage": {"value": $apiImage},
                "webImage": {"value": $webImage}
              }
            }' > ".artifacts/infra/$HEAD_SHA/runtime.parameters.json"

          az deployment group validate \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --template-file infra/azure/main.bicep \
            --parameters @".artifacts/infra/$HEAD_SHA/runtime.parameters.json"

          stderr_path=".artifacts/infra/$HEAD_SHA/deployment.stderr.log"
          attempts_path=".artifacts/infra/$HEAD_SHA/deployment-attempts.log"
          : > "$attempts_path"

          transient_pattern='(OperationExpired|GatewayTimeout|TooManyRequests|ResourceNotReady|another operation is in progress|OperationInProgress|retryable|temporar|timeout|timed out)'

          run_apply() {
            az deployment group create \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --template-file infra/azure/main.bicep \
              --parameters @".artifacts/infra/$HEAD_SHA/runtime.parameters.json" \
              --output json > ".artifacts/infra/$HEAD_SHA/deployment.json" 2> "$stderr_path"
          }

          for attempt in 1 2; do
            echo "attempt=$attempt startedAt=$(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> "$attempts_path"

            if run_apply; then
              echo "attempt=$attempt status=success finishedAt=$(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> "$attempts_path"
              break
            fi

            if [ "$attempt" -eq 1 ] && grep -Eiq "$transient_pattern" "$stderr_path"; then
              echo "attempt=$attempt status=retry transient=true finishedAt=$(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> "$attempts_path"
              echo "Transient infra apply failure detected; retrying once in 20 seconds..."
              sleep 20
              continue
            fi

            echo "attempt=$attempt status=failed transient=false finishedAt=$(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> "$attempts_path"
            echo "Infra apply failed with terminal diagnostics:" >&2
            cat "$stderr_path" >&2
            exit 1
          done

      - name: Roll active revisions after infra apply
        if: ${{ steps.stale_preinfra.outputs.is_stale != 'true' && env.KIND == 'infra' && env.ROLLOUT == 'true' }}
        run: |
          set -euo pipefail

          restart_active_revision() {
            local app="$1"
            local revision
            revision="$(az containerapp revision list \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --name "$app" \
              --query "[?properties.active==\`true\`]|[0].name" \
              --output tsv)"

            if [ -z "$revision" ]; then
              echo "No active revision found for $app" >&2
              return 1
            fi

            az containerapp revision restart \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --name "$app" \
              --revision "$revision" \
              --output none
          }

          restart_active_revision "$ACA_API_APP_NAME"
          restart_active_revision "$ACA_WEB_APP_NAME"

      - name: Login to ACR
        if: ${{ steps.stale_preinfra.outputs.is_stale != 'true' && env.KIND == 'runtime' }}
        run: az acr login --name "$ACR_NAME" --only-show-errors

      - name: Build and push runtime images
        id: runtime_images
        if: ${{ steps.stale_preinfra.outputs.is_stale != 'true' && env.KIND == 'runtime' }}
        run: |
          set -euo pipefail

          api_tag="$ACR_REGISTRY/compass-api:$HEAD_SHA"
          web_tag="$ACR_REGISTRY/compass-web:$HEAD_SHA"

          docker build -f apps/api/Dockerfile -t "$api_tag" .
          docker push "$api_tag"

          docker build -f apps/web/Dockerfile -t "$web_tag" .
          docker push "$web_tag"

          api_ref="$(docker inspect --format='{{index .RepoDigests 0}}' "$api_tag")"
          web_ref="$(docker inspect --format='{{index .RepoDigests 0}}' "$web_tag")"

          {
            echo "candidate_api_ref=$api_ref"
            echo "candidate_web_ref=$web_ref"
            echo "api_tag=$api_tag"
            echo "web_tag=$web_tag"
          } >> "$GITHUB_OUTPUT"

      - name: Resolve candidate refs
        id: candidate_refs
        if: ${{ steps.stale_preinfra.outputs.is_stale != 'true' }}
        run: |
          set -euo pipefail

          if [ "$KIND" = "runtime" ]; then
            api_ref='${{ steps.runtime_images.outputs.candidate_api_ref }}'
            web_ref='${{ steps.runtime_images.outputs.candidate_web_ref }}'
          else
            api_ref='${{ steps.current_state.outputs.current_api_ref }}'
            web_ref='${{ steps.current_state.outputs.current_web_ref }}'
          fi

          echo "candidate_api_ref=$api_ref" >> "$GITHUB_OUTPUT"
          echo "candidate_web_ref=$web_ref" >> "$GITHUB_OUTPUT"

      - name: Write candidate manifest artifact
        if: ${{ steps.stale_preinfra.outputs.is_stale != 'true' }}
        run: |
          mkdir -p ".artifacts/deploy/$HEAD_SHA" ".artifacts/release/$HEAD_SHA"
          cat > ".artifacts/deploy/$HEAD_SHA/candidate-manifest.json" <<JSON
          {
            "schemaVersion": "1",
            "generatedAt": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "baseSha": "$BASE_SHA",
            "headSha": "$HEAD_SHA",
            "baseSource": "$BASE_SOURCE",
            "baseDeploymentId": "${BASE_DEPLOYMENT_ID:-}",
            "kind": "$KIND",
            "current": {
              "api": "${{ steps.current_state.outputs.current_api_ref }}",
              "web": "${{ steps.current_state.outputs.current_web_ref }}"
            },
            "candidate": {
              "api": "${{ steps.candidate_refs.outputs.candidate_api_ref }}",
              "web": "${{ steps.candidate_refs.outputs.candidate_web_ref }}"
            }
          }
          JSON
          cp ".artifacts/deploy/$HEAD_SHA/candidate-manifest.json" ".artifacts/release/$HEAD_SHA/manifest.json"

      - name: Stale guard before migration+deploy boundary
        id: stale_preboundary
        if: ${{ steps.stale_preinfra.outputs.is_stale != 'true' }}
        run: |
          if [ "$KIND" != "runtime" ]; then
            echo "is_stale=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          set +e
          node scripts/deploy/assert-current-main-sha.mjs
          code=$?
          if [ "$code" -eq 0 ]; then
            echo "is_stale=false" >> "$GITHUB_OUTPUT"
          else
            echo "is_stale=true" >> "$GITHUB_OUTPUT"
            echo "Stale candidate before migration+deploy boundary; skipping runtime promotion."
          fi
          exit 0

      - name: Update migration job image
        if: ${{ steps.stale_preinfra.outputs.is_stale != 'true' && env.KIND == 'runtime' && steps.stale_preboundary.outputs.is_stale != 'true' }}
        run: |
          az containerapp job update \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$ACA_MIGRATE_JOB_NAME" \
            --image "${{ steps.candidate_refs.outputs.candidate_api_ref }}" \
            --output none

      - name: Run migration job
        id: migration_start
        if: ${{ steps.stale_preinfra.outputs.is_stale != 'true' && env.KIND == 'runtime' && env.NEEDS_MIGRATIONS == 'true' && steps.stale_preboundary.outputs.is_stale != 'true' }}
        env:
          AZURE_RESOURCE_GROUP: ${{ env.AZURE_RESOURCE_GROUP }}
          ACA_MIGRATE_JOB_NAME: ${{ env.ACA_MIGRATE_JOB_NAME }}
        run: node scripts/deploy/start-migration-job.mjs

      - name: Wait for migration completion
        id: migration_wait
        if: ${{ steps.stale_preinfra.outputs.is_stale != 'true' && env.KIND == 'runtime' && env.NEEDS_MIGRATIONS == 'true' && steps.stale_preboundary.outputs.is_stale != 'true' }}
        env:
          AZURE_RESOURCE_GROUP: ${{ env.AZURE_RESOURCE_GROUP }}
          ACA_MIGRATE_JOB_NAME: ${{ env.ACA_MIGRATE_JOB_NAME }}
          MIGRATION_EXECUTION_NAME: ${{ steps.migration_start.outputs.migration_execution_name }}
          MIGRATION_TIMEOUT_SECONDS: 900
        run: node scripts/deploy/wait-migration-job.mjs

      - name: Deploy API via ACA deploy action
        if: ${{ steps.stale_preinfra.outputs.is_stale != 'true' && env.KIND == 'runtime' && steps.stale_preboundary.outputs.is_stale != 'true' }}
        uses: azure/container-apps-deploy-action@v1
        with:
          imageToDeploy: ${{ steps.candidate_refs.outputs.candidate_api_ref }}
          containerAppName: ${{ env.ACA_API_APP_NAME }}
          resourceGroup: ${{ env.AZURE_RESOURCE_GROUP }}
          disableTelemetry: true

      - name: Deploy Web via ACA deploy action
        if: ${{ steps.stale_preinfra.outputs.is_stale != 'true' && env.KIND == 'runtime' && steps.stale_preboundary.outputs.is_stale != 'true' }}
        uses: azure/container-apps-deploy-action@v1
        with:
          imageToDeploy: ${{ steps.candidate_refs.outputs.candidate_web_ref }}
          containerAppName: ${{ env.ACA_WEB_APP_NAME }}
          resourceGroup: ${{ env.AZURE_RESOURCE_GROUP }}
          disableTelemetry: true

      - name: Assert single-revision and scale drift policy
        if: ${{ steps.stale_preinfra.outputs.is_stale != 'true' && (env.KIND == 'infra' || (env.KIND == 'runtime' && steps.stale_preboundary.outputs.is_stale != 'true')) }}
        run: |
          set -euo pipefail

          for app in "$ACA_API_APP_NAME" "$ACA_WEB_APP_NAME"; do
            converged="false"

            for _ in {1..12}; do
              app_json=$(az containerapp show \
                --resource-group "$AZURE_RESOURCE_GROUP" \
                --name "$app" \
                --output json)

              revisions_json=$(az containerapp revision list \
                --resource-group "$AZURE_RESOURCE_GROUP" \
                --name "$app" \
                --output json)

              mode=$(jq -r '.properties.configuration.activeRevisionsMode // ""' <<<"$app_json")
              normalized_mode=$(echo "$mode" | tr '[:upper:]' '[:lower:]')

              min_replicas=$(jq -r '.properties.template.scale.minReplicas // 0' <<<"$app_json")
              max_replicas=$(jq -r '.properties.template.scale.maxReplicas // 0' <<<"$app_json")
              cpu=$(jq -r '.properties.template.containers[0].resources.cpu // ""' <<<"$app_json")
              memory=$(jq -r '.properties.template.containers[0].resources.memory // ""' <<<"$app_json")
              max_inactive_revisions=$(jq -r '.properties.configuration.maxInactiveRevisions // ""' <<<"$app_json")
              latest_revision=$(jq -r '.properties.latestRevisionName // ""' <<<"$app_json")

              active_count=$(jq '[.[] | select(.properties.active == true)] | length' <<<"$revisions_json")
              active_revision=$(jq -r '[.[] | select(.properties.active == true)][0].name // ""' <<<"$revisions_json")

              if [ "$normalized_mode" != "single" ]; then
                echo "$app is not in single revision mode (actual: $mode)" >&2
                exit 1
              fi

              if [ "${min_replicas:-0}" != "0" ]; then
                echo "$app minReplicas drifted (actual: ${min_replicas:-unset})" >&2
                exit 1
              fi

              if [ "${max_replicas:-0}" != "1" ]; then
                echo "$app maxReplicas drifted (actual: ${max_replicas:-unset})" >&2
                exit 1
              fi

              if [ "${cpu:-unset}" != "0.25" ]; then
                echo "$app cpu drifted (actual: ${cpu:-unset})" >&2
                exit 1
              fi

              if [ "${memory:-unset}" != "0.5Gi" ]; then
                echo "$app memory drifted (actual: ${memory:-unset})" >&2
                exit 1
              fi

              if [ -n "${max_inactive_revisions:-}" ] && ! [[ "${max_inactive_revisions}" =~ ^[0-9]+$ ]]; then
                echo "$app maxInactiveRevisions is not numeric (actual: ${max_inactive_revisions:-unset})" >&2
                exit 1
              fi

              if [ -n "${max_inactive_revisions:-}" ] && [ "${max_inactive_revisions}" -gt 2 ]; then
                echo "$app maxInactiveRevisions drifted (actual: ${max_inactive_revisions:-unset})" >&2
                exit 1
              fi

              if [ "${active_count:-0}" = "1" ] && [ -n "$latest_revision" ] && [ "$active_revision" = "$latest_revision" ]; then
                converged="true"
                break
              fi

              sleep 10
            done

            if [ "$converged" != "true" ]; then
              echo "$app did not converge to latest revision as single active revision within 120 seconds" >&2
              exit 1
            fi
          done

      - name: API smoke verification
        if: ${{ steps.stale_preinfra.outputs.is_stale != 'true' && (env.KIND == 'infra' || (env.KIND == 'runtime' && steps.stale_preboundary.outputs.is_stale != 'true')) }}
        env:
          TARGET_API_BASE_URL: ${{ steps.current_state.outputs.api_prod_url }}
        run: node scripts/deploy/verify-api-smoke.mjs

      - name: Install Playwright browser
        if: ${{ steps.stale_preinfra.outputs.is_stale != 'true' && (env.KIND == 'infra' || (env.KIND == 'runtime' && steps.stale_preboundary.outputs.is_stale != 'true')) }}
        run: pnpm exec playwright install --with-deps chromium

      - name: Browser evidence
        if: ${{ steps.stale_preinfra.outputs.is_stale != 'true' && (env.KIND == 'infra' || (env.KIND == 'runtime' && steps.stale_preboundary.outputs.is_stale != 'true')) }}
        env:
          HEAD_SHA: ${{ env.HEAD_SHA }}
          PR_NUMBER: 0
          RISK_TIER: high
          WEB_BASE_URL: ${{ steps.current_state.outputs.web_prod_url }}
          BROWSER_SMOKE_PAYLOAD_TIMEOUT_MS: "45000"
          EXPECTED_ENTRYPOINT: /
          REQUIRED_FLOW_IDS_JSON: '["compass-smoke"]'
        run: pnpm ci:browser-evidence

      - name: Record successful production deployment
        id: record_production_deployment
        if: ${{ success() && steps.stale_preinfra.outputs.is_stale != 'true' && (env.KIND == 'infra' || (env.KIND == 'runtime' && steps.stale_preboundary.outputs.is_stale != 'true')) }}
        env:
          GITHUB_TOKEN: ${{ github.token }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          TARGET_ENVIRONMENT: production
          HEAD_SHA: ${{ env.HEAD_SHA }}
          DEPLOY_LOG_URL: ${{ format('{0}/{1}/actions/runs/{2}', github.server_url, github.repository, github.run_id) }}
          DEPLOY_ENVIRONMENT_URL: ${{ steps.current_state.outputs.web_prod_url }}
          CANDIDATE_API_REF: ${{ steps.candidate_refs.outputs.candidate_api_ref }}
          CANDIDATE_WEB_REF: ${{ steps.candidate_refs.outputs.candidate_web_ref }}
          KIND: ${{ env.KIND }}
        run: node scripts/deploy/record-production-deployment.mjs

      - name: Write final deploy result artifact
        if: ${{ always() }}
        env:
          JOB_STATUS: ${{ job.status }}
        run: |
          mkdir -p ".artifacts/deploy/$HEAD_SHA" ".artifacts/release/$HEAD_SHA"
          cat > ".artifacts/deploy/$HEAD_SHA/result.json" <<JSON
          {
            "schemaVersion": "1",
            "generatedAt": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "baseSha": "$BASE_SHA",
            "headSha": "$HEAD_SHA",
            "baseSource": "$BASE_SOURCE",
            "baseDeploymentId": "${BASE_DEPLOYMENT_ID:-}",
            "newDeploymentId": "${{ steps.record_production_deployment.outputs.deployment_id || '' }}",
            "tier": "$RISK_TIER",
            "kind": "$KIND",
            "stale": {
              "beforeInfra": "${{ steps.stale_preinfra.outputs.is_stale || 'false' }}",
              "beforeBoundary": "${{ steps.stale_preboundary.outputs.is_stale || 'false' }}"
            },
            "status": "${JOB_STATUS:-unknown}",
            "images": {
              "currentApi": "${{ steps.current_state.outputs.current_api_ref }}",
              "currentWeb": "${{ steps.current_state.outputs.current_web_ref }}",
              "candidateApi": "${{ steps.candidate_refs.outputs.candidate_api_ref }}",
              "candidateWeb": "${{ steps.candidate_refs.outputs.candidate_web_ref }}"
            },
            "urls": {
              "api": "${{ steps.current_state.outputs.api_prod_url }}",
              "web": "${{ steps.current_state.outputs.web_prod_url }}"
            }
          }
          JSON
          cp ".artifacts/deploy/$HEAD_SHA/result.json" ".artifacts/release/$HEAD_SHA/result.json"

      - name: Upload deploy artifacts
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: deploy-${{ env.HEAD_SHA }}
          path: .artifacts/deploy/${{ env.HEAD_SHA }}
          if-no-files-found: warn

      - name: Upload browser evidence artifact
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: browser-evidence-${{ env.HEAD_SHA }}
          path: .artifacts/browser-evidence/${{ env.HEAD_SHA }}
          if-no-files-found: warn

      - name: Upload infra artifact
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: infra-apply-${{ env.HEAD_SHA }}
          path: .artifacts/infra/${{ env.HEAD_SHA }}
          if-no-files-found: ignore

      - name: Upload release artifact
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: release-${{ env.HEAD_SHA }}
          path: .artifacts/release/${{ env.HEAD_SHA }}
          if-no-files-found: warn

  report:
    name: report
    needs:
      - classify
      - checks
      - promote
    if: ${{ always() }}
    runs-on: ubuntu-latest
    steps:
      - name: Write release summary
        env:
          HEAD_SHA: ${{ github.sha }}
          BASE_SHA: ${{ needs.classify.outputs.base_sha }}
          BASE_SOURCE: ${{ needs.classify.outputs.base_source }}
          BASE_DEPLOYMENT_ID: ${{ needs.classify.outputs.base_deployment_id }}
          KIND: ${{ needs.classify.outputs.kind }}
          ROLLOUT: ${{ needs.classify.outputs.rollout }}
          NEEDS_INFRA: ${{ needs.classify.outputs.needs_infra }}
          NEEDS_MIGRATIONS: ${{ needs.classify.outputs.needs_migrations }}
          CHECKS_RESULT: ${{ needs.checks.result }}
          PROMOTE_RESULT: ${{ needs.promote.result }}
          STALE_PREINFRA: ${{ needs.promote.outputs.stale_preinfra }}
          STALE_PREBOUNDARY: ${{ needs.promote.outputs.stale_preboundary }}
          NEW_DEPLOYMENT_ID: ${{ needs.promote.outputs.new_deployment_id }}
          CURRENT_API_REF: ${{ needs.promote.outputs.current_api_ref }}
          CURRENT_WEB_REF: ${{ needs.promote.outputs.current_web_ref }}
          CANDIDATE_API_REF: ${{ needs.promote.outputs.candidate_api_ref }}
          CANDIDATE_WEB_REF: ${{ needs.promote.outputs.candidate_web_ref }}
          API_PROD_URL: ${{ needs.promote.outputs.api_prod_url }}
          WEB_PROD_URL: ${{ needs.promote.outputs.web_prod_url }}
        run: |
          mkdir -p ".artifacts/release/$HEAD_SHA"
          cat > ".artifacts/release/$HEAD_SHA/result.json" <<JSON
          {
            "schemaVersion": "1",
            "generatedAt": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "baseSha": "$BASE_SHA",
            "headSha": "$HEAD_SHA",
            "baseSource": "$BASE_SOURCE",
            "baseDeploymentId": "${BASE_DEPLOYMENT_ID:-}",
            "newDeploymentId": "${NEW_DEPLOYMENT_ID:-}",
            "kind": "$KIND",
            "rollout": "$ROLLOUT",
            "needsInfra": "$NEEDS_INFRA",
            "needsMigrations": "$NEEDS_MIGRATIONS",
            "checksResult": "${CHECKS_RESULT:-skipped}",
            "promoteResult": "${PROMOTE_RESULT:-skipped}",
            "stale": {
              "beforeInfra": "${STALE_PREINFRA:-false}",
              "beforeBoundary": "${STALE_PREBOUNDARY:-false}"
            },
            "refs": {
              "currentApi": "${CURRENT_API_REF:-}",
              "currentWeb": "${CURRENT_WEB_REF:-}",
              "candidateApi": "${CANDIDATE_API_REF:-}",
              "candidateWeb": "${CANDIDATE_WEB_REF:-}"
            },
            "urls": {
              "api": "${API_PROD_URL:-}",
              "web": "${WEB_PROD_URL:-}"
            }
          }
          JSON

      - name: Upload release summary artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-summary-${{ github.sha }}
          path: .artifacts/release/${{ github.sha }}/result.json
          if-no-files-found: warn
