name: Desktop Release

on:
  workflow_dispatch:
    inputs:
      candidate_sha:
        description: Accepted candidate SHA from main
        required: true
        type: string
      release_tag:
        description: Release tag for installers (for example desktop-v0.1.0)
        required: true
        type: string
      web_base_url:
        description: HTTPS URL loaded by desktop renderer
        required: true
        type: string
      draft:
        description: Create draft release
        required: false
        default: true
        type: boolean
      signing_mode:
        description: Installer signing policy (`signed`, `unsigned`, `unsigned-macos`, `unsigned-windows`)
        required: false
        default: signed
        type: choice
        options:
          - signed
          - unsigned
          - unsigned-macos
          - unsigned-windows
      candidate_validation:
        description: Candidate validation policy (`strict` requires successful deployment pipeline; `main-only` is for unsigned testing)
        required: false
        default: strict
        type: choice
        options:
          - strict
          - main-only

permissions:
  actions: read
  contents: write
  id-token: write

jobs:
  validate_candidate:
    name: validate-candidate
    runs-on: ubuntu-latest
    outputs:
      deployment_pipeline_run_id: ${{ steps.validate.outputs.deployment_pipeline_run_id }}
      candidate_sha: ${{ steps.validate.outputs.candidate_sha }}
      release_version: ${{ steps.version.outputs.release_version }}
    steps:
      - name: Validate accepted candidate on main
        id: validate
        env:
          GITHUB_TOKEN: ${{ github.token }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          CANDIDATE_SHA: ${{ inputs.candidate_sha }}
          CANDIDATE_VALIDATION: ${{ inputs.candidate_validation }}
          SIGNING_MODE: ${{ inputs.signing_mode }}
        run: |
          set -euo pipefail

          node <<'NODE'
          const fs = require("node:fs");

          const token = process.env.GITHUB_TOKEN;
          const repository = process.env.GITHUB_REPOSITORY;
          const candidateSha = process.env.CANDIDATE_SHA;
          const candidateValidation = process.env.CANDIDATE_VALIDATION || "strict";
          const signingMode = process.env.SIGNING_MODE || "signed";
          const outputPath = process.env.GITHUB_OUTPUT;
          const apiVersion = "2022-11-28";

          async function request(pathname) {
            const response = await fetch(`https://api.github.com${pathname}`, {
              headers: {
                Accept: "application/vnd.github+json",
                Authorization: `Bearer ${token}`,
                "X-GitHub-Api-Version": apiVersion
              }
            });

            if (!response.ok) {
              const body = await response.text();
              throw new Error(`GitHub API request failed (${response.status}) ${pathname}\n${body}`);
            }

            return response.json();
          }

          function writeOutputs(runId) {
            fs.appendFileSync(outputPath, `deployment_pipeline_run_id=${runId}\n`);
            fs.appendFileSync(outputPath, `candidate_sha=${candidateSha}\n`);
          }

          (async () => {
            if (!["strict", "main-only"].includes(candidateValidation)) {
              throw new Error(`Unsupported candidate_validation value: ${candidateValidation}`);
            }

            if (candidateValidation === "main-only" && signingMode === "signed") {
              throw new Error("candidate_validation=main-only is not allowed with signing_mode=signed");
            }

            if (candidateValidation === "strict") {
              const data = await request(
                `/repos/${repository}/actions/workflows/deployment-pipeline.yml/runs?status=success&per_page=100`
              );

              const run = (data.workflow_runs || []).find(
                (entry) =>
                  entry.head_sha === candidateSha &&
                  entry.conclusion === "success" &&
                  entry.head_branch === "main"
              );

              if (!run) {
                throw new Error(
                  `No successful Deployment Pipeline run on main found for candidate ${candidateSha}`
                );
              }

              writeOutputs(String(run.id));
              return;
            }

            const comparison = await request(`/repos/${repository}/compare/${candidateSha}...main`);
            const status = comparison.status;
            if (status !== "behind" && status !== "identical") {
              throw new Error(
                `Candidate ${candidateSha} is not reachable from main (compare status: ${status})`
              );
            }

            const commitStageRuns = await request(
              `/repos/${repository}/actions/workflows/commit-stage.yml/runs?status=success&per_page=100`
            );
            const commitStageRun = (commitStageRuns.workflow_runs || []).find(
              (entry) => entry.head_sha === candidateSha && entry.conclusion === "success"
            );

            writeOutputs(commitStageRun ? String(commitStageRun.id) : "main-only");
          })().catch((error) => {
            console.error(error instanceof Error ? error.message : String(error));
            process.exit(1);
          });
          NODE

      - name: Resolve release version
        id: version
        run: |
          set -euo pipefail
          tag="${{ inputs.release_tag }}"
          version="${tag#desktop-}"
          version="${version#v}"
          if [ -z "$version" ]; then
            echo "Unable to resolve release version from tag: $tag" >&2
            exit 1
          fi
          echo "release_version=$version" >> "$GITHUB_OUTPUT"

  build_macos:
    name: build-macos
    needs:
      - validate_candidate
    runs-on: macos-14
    environment: desktop-release
    steps:
      - name: Checkout candidate
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.validate_candidate.outputs.candidate_sha }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.30.1

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc
          cache: pnpm
          cache-dependency-path: pnpm-lock.yaml

      - name: Install dependencies
        env:
          npm_config_node_linker: hoisted
          npm_config_allow_build_scripts: esbuild,sharp,electron,fs-xattr,macos-alias
        run: pnpm install --frozen-lockfile

      - name: Decode signing assets
        id: signing_assets
        if: ${{ inputs.signing_mode == 'signed' || inputs.signing_mode == 'unsigned-windows' }}
        env:
          CERT_P12_BASE64: ${{ secrets.MACOS_SIGNING_CERT_P12_BASE64 }}
          APPLE_API_KEY_BASE64: ${{ secrets.APPLE_API_KEY_P8_BASE64 }}
        run: |
          set -euo pipefail

          cert_path="$RUNNER_TEMP/macos-signing-cert.p12"
          api_key_path="$RUNNER_TEMP/apple-api-key.p8"

          CERT_P12_BASE64="$CERT_P12_BASE64" APPLE_API_KEY_BASE64="$APPLE_API_KEY_BASE64" \
            CERT_PATH="$cert_path" API_KEY_PATH="$api_key_path" node <<'NODE'
          const fs = require("node:fs");

          const certPath = process.env.CERT_PATH;
          const apiKeyPath = process.env.API_KEY_PATH;

          fs.writeFileSync(certPath, Buffer.from(process.env.CERT_P12_BASE64 || "", "base64"));
          fs.writeFileSync(apiKeyPath, Buffer.from(process.env.APPLE_API_KEY_BASE64 || "", "base64"));
          NODE

          echo "cert_path=$cert_path" >> "$GITHUB_OUTPUT"
          echo "api_key_path=$api_key_path" >> "$GITHUB_OUTPUT"

      - name: Configure temporary keychain
        if: ${{ inputs.signing_mode == 'signed' || inputs.signing_mode == 'unsigned-windows' }}
        env:
          CERT_PATH: ${{ steps.signing_assets.outputs.cert_path }}
          CERT_PASSWORD: ${{ secrets.MACOS_SIGNING_CERT_PASSWORD }}
        run: |
          set -euo pipefail

          keychain="$RUNNER_TEMP/build.keychain-db"
          keychain_password="$(openssl rand -base64 24)"

          security create-keychain -p "$keychain_password" "$keychain"
          security set-keychain-settings -lut 21600 "$keychain"
          security unlock-keychain -p "$keychain_password" "$keychain"
          security list-keychains -d user -s "$keychain"
          security default-keychain -d user -s "$keychain"

          security import "$CERT_PATH" -k "$keychain" -P "$CERT_PASSWORD" -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple: -s -k "$keychain_password" "$keychain"

      - name: Build signed macOS DMG
        if: ${{ inputs.signing_mode == 'signed' || inputs.signing_mode == 'unsigned-windows' }}
        env:
          COMPASS_DESKTOP_START_URL: ${{ inputs.web_base_url }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER_ID: ${{ secrets.APPLE_API_ISSUER_ID }}
          APPLE_API_KEY_PATH: ${{ steps.signing_assets.outputs.api_key_path }}
        run: pnpm --filter @compass/desktop make:mac

      - name: Build unsigned macOS DMG
        if: ${{ inputs.signing_mode == 'unsigned' || inputs.signing_mode == 'unsigned-macos' }}
        env:
          COMPASS_DESKTOP_START_URL: ${{ inputs.web_base_url }}
        run: pnpm --filter @compass/desktop make:mac

      - name: Verify macOS signing and notarization
        if: ${{ inputs.signing_mode == 'signed' || inputs.signing_mode == 'unsigned-windows' }}
        run: |
          set -euo pipefail

          app_path="$(find apps/desktop/out -type d -name '*.app' | head -n 1)"
          dmg_path="$(find apps/desktop/out/make -type f -name '*.dmg' | head -n 1)"

          if [ -z "$app_path" ] || [ -z "$dmg_path" ]; then
            echo "Missing macOS app or DMG output." >&2
            exit 1
          fi

          codesign --verify --deep --strict --verbose=2 "$app_path"
          spctl --assess --type execute --verbose=4 "$app_path"
          xcrun stapler validate "$app_path"

      - name: Verify unsigned macOS package output
        if: ${{ inputs.signing_mode == 'unsigned' || inputs.signing_mode == 'unsigned-macos' }}
        run: |
          set -euo pipefail

          app_path="$(find apps/desktop/out -type d -name '*.app' | head -n 1)"
          dmg_path="$(find apps/desktop/out/make -type f -name '*.dmg' | head -n 1)"

          if [ -z "$app_path" ] || [ -z "$dmg_path" ]; then
            echo "Missing macOS app or DMG output." >&2
            exit 1
          fi

          echo "Unsigned test artifacts generated:"
          echo "  app: $app_path"
          echo "  dmg: $dmg_path"

      - name: Prepare macOS installer artifact
        id: collect
        run: |
          set -euo pipefail

          dmg_path="$(find apps/desktop/out/make -type f -name '*.dmg' | head -n 1)"
          version="${{ needs.validate_candidate.outputs.release_version }}"
          artifact_name="Compass-${version}-arm64.dmg"
          artifact_path="$RUNNER_TEMP/$artifact_name"

          cp "$dmg_path" "$artifact_path"
          echo "artifact_path=$artifact_path" >> "$GITHUB_OUTPUT"

      - name: Upload macOS installer artifact
        uses: actions/upload-artifact@v4
        with:
          name: desktop-macos-${{ needs.validate_candidate.outputs.candidate_sha }}
          path: ${{ steps.collect.outputs.artifact_path }}
          if-no-files-found: error

  build_windows:
    name: build-windows
    needs:
      - validate_candidate
    runs-on: windows-latest
    environment: desktop-release
    steps:
      - name: Checkout candidate
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.validate_candidate.outputs.candidate_sha }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.30.1

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc
          cache: pnpm
          cache-dependency-path: pnpm-lock.yaml

      - name: Install dependencies
        env:
          npm_config_node_linker: hoisted
          npm_config_allow_build_scripts: esbuild,sharp,electron,fs-xattr,macos-alias
        run: pnpm install --frozen-lockfile

      - name: Install WiX toolset
        run: choco install wixtoolset --yes

      - name: Build Windows MSI
        env:
          COMPASS_DESKTOP_START_URL: ${{ inputs.web_base_url }}
        run: pnpm --filter @compass/desktop make:win

      - name: Collect MSI path
        id: collect
        shell: pwsh
        run: |
          $msi = Get-ChildItem "apps/desktop/out/make" -Filter "*.msi" -Recurse | Select-Object -First 1
          if ($null -eq $msi) {
            throw "Missing MSI output in apps/desktop/out/make"
          }

          $version = "${{ needs.validate_candidate.outputs.release_version }}"
          $artifactName = "Compass-$version-x64.msi"
          $artifactPath = Join-Path $env:RUNNER_TEMP $artifactName
          Copy-Item $msi.FullName $artifactPath -Force

          "msi_path=$artifactPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Azure login for signing
        if: ${{ inputs.signing_mode == 'signed' || inputs.signing_mode == 'unsigned-macos' }}
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Sign MSI with Azure Artifact Signing
        if: ${{ inputs.signing_mode == 'signed' || inputs.signing_mode == 'unsigned-macos' }}
        uses: azure/artifact-signing-action@v1
        with:
          endpoint: ${{ vars.TRUSTED_SIGNING_ENDPOINT }}
          signing-account-name: ${{ vars.TRUSTED_SIGNING_ACCOUNT_NAME }}
          certificate-profile-name: ${{ vars.TRUSTED_SIGNING_PROFILE_NAME }}
          files: ${{ steps.collect.outputs.msi_path }}
          file-digest: SHA256
          timestamp-rfc3161: http://timestamp.acs.microsoft.com
          timestamp-digest: SHA256

      - name: Verify Authenticode signature
        if: ${{ inputs.signing_mode == 'signed' || inputs.signing_mode == 'unsigned-macos' }}
        shell: pwsh
        run: |
          $signature = Get-AuthenticodeSignature "${{ steps.collect.outputs.msi_path }}"
          if ($signature.Status -ne "Valid") {
            throw "Invalid Windows signature status: $($signature.Status)"
          }

      - name: Verify unsigned Windows package output
        if: ${{ inputs.signing_mode == 'unsigned' || inputs.signing_mode == 'unsigned-windows' }}
        shell: pwsh
        run: |
          $signature = Get-AuthenticodeSignature "${{ steps.collect.outputs.msi_path }}"
          Write-Host "Unsigned MSI signature status: $($signature.Status)"
          if ($signature.Status -eq "Valid") {
            throw "Expected unsigned MSI but signature status is Valid."
          }

      - name: Upload Windows installer artifact
        uses: actions/upload-artifact@v4
        with:
          name: desktop-windows-${{ needs.validate_candidate.outputs.candidate_sha }}
          path: ${{ steps.collect.outputs.msi_path }}
          if-no-files-found: error

  publish_release:
    name: publish-release
    needs:
      - validate_candidate
      - build_macos
      - build_windows
    if: ${{ needs.validate_candidate.result == 'success' && needs.build_macos.result == 'success' && needs.build_windows.result == 'success' }}
    runs-on: ubuntu-latest
    steps:
      - name: Download macOS installer artifact
        uses: actions/download-artifact@v4
        with:
          name: desktop-macos-${{ needs.validate_candidate.outputs.candidate_sha }}
          path: .artifacts/desktop/${{ needs.validate_candidate.outputs.candidate_sha }}/installers

      - name: Download Windows installer artifact
        uses: actions/download-artifact@v4
        with:
          name: desktop-windows-${{ needs.validate_candidate.outputs.candidate_sha }}
          path: .artifacts/desktop/${{ needs.validate_candidate.outputs.candidate_sha }}/installers

      - name: Generate checksums
        working-directory: .artifacts/desktop/${{ needs.validate_candidate.outputs.candidate_sha }}/installers
        run: |
          set -euo pipefail
          shopt -s nullglob

          files=( *.dmg *.msi )
          if [ "${#files[@]}" -eq 0 ]; then
            echo "No installer artifacts found to checksum." >&2
            exit 1
          fi

          sha256sum "${files[@]}" > SHA256SUMS.txt

      - name: Create release manifest
        run: |
          set -euo pipefail

          artifact_dir=".artifacts/desktop/${{ needs.validate_candidate.outputs.candidate_sha }}"
          installers_dir="$artifact_dir/installers"
          manifest_path="$artifact_dir/release-manifest.json"

          node <<'NODE'
          const fs = require("node:fs");
          const path = require("node:path");
          const crypto = require("node:crypto");

          const artifactDir = process.env.ARTIFACT_DIR;
          const installersDir = process.env.INSTALLERS_DIR;
          const manifestPath = process.env.MANIFEST_PATH;
          const releaseTag = process.env.RELEASE_TAG;
          const candidateSha = process.env.CANDIDATE_SHA;
          const deploymentPipelineRunId = process.env.DEPLOYMENT_PIPELINE_RUN_ID;

          const files = fs
            .readdirSync(installersDir)
            .filter((name) => [".dmg", ".msi", ".txt"].includes(path.extname(name)))
            .sort();

          const artifacts = files.map((name) => {
            const filePath = path.join(installersDir, name);
            const content = fs.readFileSync(filePath);
            return {
              fileName: name,
              bytes: content.length,
              sha256: crypto.createHash("sha256").update(content).digest("hex")
            };
          });

          const payload = {
            schemaVersion: "1",
            generatedAt: new Date().toISOString(),
            candidateSha,
            deploymentPipelineRunId,
            releaseTag,
            artifacts
          };

          fs.mkdirSync(artifactDir, { recursive: true });
          fs.writeFileSync(manifestPath, `${JSON.stringify(payload, null, 2)}\n`);
          NODE
        env:
          ARTIFACT_DIR: .artifacts/desktop/${{ needs.validate_candidate.outputs.candidate_sha }}
          INSTALLERS_DIR: .artifacts/desktop/${{ needs.validate_candidate.outputs.candidate_sha }}/installers
          MANIFEST_PATH: .artifacts/desktop/${{ needs.validate_candidate.outputs.candidate_sha }}/release-manifest.json
          RELEASE_TAG: ${{ inputs.release_tag }}
          CANDIDATE_SHA: ${{ needs.validate_candidate.outputs.candidate_sha }}
          DEPLOYMENT_PIPELINE_RUN_ID: ${{ needs.validate_candidate.outputs.deployment_pipeline_run_id }}

      - name: Publish GitHub release assets
        env:
          GH_TOKEN: ${{ github.token }}
          RELEASE_TAG: ${{ inputs.release_tag }}
          DRAFT: ${{ inputs.draft }}
          CANDIDATE_SHA: ${{ needs.validate_candidate.outputs.candidate_sha }}
          SIGNING_MODE: ${{ inputs.signing_mode }}
        run: |
          set -euo pipefail
          shopt -s nullglob

          installers_dir=".artifacts/desktop/$CANDIDATE_SHA/installers"
          cd "$installers_dir"

          dmg_files=( *.dmg )
          msi_files=( *.msi )
          if [ "${#dmg_files[@]}" -eq 0 ]; then
            echo "Expected at least one DMG in release installers directory." >&2
            exit 1
          fi
          if [ "${#msi_files[@]}" -eq 0 ]; then
            echo "Expected at least one MSI in release installers directory." >&2
            exit 1
          fi

          dmg_file="${dmg_files[0]}"
          msi_file="${msi_files[0]}"
          sums_file="SHA256SUMS.txt"
          assets=( "$dmg_file" "$msi_file" "$sums_file" )
          notes="Desktop installers for candidate ${CANDIDATE_SHA}"

          case "$SIGNING_MODE" in
            signed)
              notes="$notes"$'\n\n'"Signing mode: signed (macOS signed/notarized, Windows signed)."
              ;;
            unsigned)
              notes="$notes"$'\n\n'"Signing mode: unsigned (macOS unsigned, Windows unsigned) for internal testing."
              notes="$notes"$'\n\n'"macOS unsigned install:"
              notes="$notes"$'\n'"1. Copy Compass.app from the DMG into /Applications."
              notes="$notes"$'\n'"2. Run: xattr -dr com.apple.quarantine \"/Applications/Compass.app\""
              notes="$notes"$'\n'"3. Launch Compass.app."
              notes="$notes"$'\n\n'"Windows unsigned install:"
              notes="$notes"$'\n'"1. Run the MSI."
              notes="$notes"$'\n'"2. If SmartScreen warns, select More info, then Run anyway."
              ;;
            unsigned-macos)
              notes="$notes"$'\n\n'"Signing mode: unsigned-macos (macOS unsigned, Windows signed) for internal testing."
              notes="$notes"$'\n\n'"macOS unsigned install:"
              notes="$notes"$'\n'"1. Copy Compass.app from the DMG into /Applications."
              notes="$notes"$'\n'"2. Run: xattr -dr com.apple.quarantine \"/Applications/Compass.app\""
              notes="$notes"$'\n'"3. Launch Compass.app."
              ;;
            unsigned-windows)
              notes="$notes"$'\n\n'"Signing mode: unsigned-windows (macOS signed/notarized, Windows unsigned) for internal testing."
              notes="$notes"$'\n\n'"Windows unsigned install:"
              notes="$notes"$'\n'"1. Run the MSI."
              notes="$notes"$'\n'"2. If SmartScreen warns, select More info, then Run anyway."
              ;;
            *)
              echo "Unsupported signing mode: $SIGNING_MODE" >&2
              exit 1
              ;;
          esac

          if gh release view "$RELEASE_TAG" >/dev/null 2>&1; then
            gh release upload "$RELEASE_TAG" "${assets[@]}" --clobber
            gh release edit "$RELEASE_TAG" --title "$RELEASE_TAG" --notes "$notes"
          else
            if [ "$DRAFT" = "true" ]; then
              gh release create "$RELEASE_TAG" "${assets[@]}" --title "$RELEASE_TAG" --notes "$notes" --draft
            else
              gh release create "$RELEASE_TAG" "${assets[@]}" --title "$RELEASE_TAG" --notes "$notes"
            fi
          fi

      - name: Upload desktop release manifest artifact
        uses: actions/upload-artifact@v4
        with:
          name: desktop-release-${{ needs.validate_candidate.outputs.candidate_sha }}
          path: .artifacts/desktop/${{ needs.validate_candidate.outputs.candidate_sha }}/release-manifest.json
          if-no-files-found: error
