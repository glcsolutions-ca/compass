name: Desktop Release (Compatibility)

on:
  workflow_dispatch:
    inputs:
      candidate_sha:
        description: Accepted candidate SHA from main
        required: true
        type: string
      release_tag:
        description: Release tag for installers (for example desktop-v0.1.0)
        required: true
        type: string
      web_base_url:
        description: HTTPS URL loaded by desktop renderer
        required: true
        type: string
      draft:
        description: Create draft release
        required: false
        default: true
        type: boolean

permissions:
  actions: read
  contents: write
  id-token: write

jobs:
  validate_candidate:
    name: validate-candidate
    runs-on: ubuntu-latest
    outputs:
      cloud_deployment_pipeline_run_id: ${{ steps.validate.outputs.cloud_deployment_pipeline_run_id }}
      candidate_sha: ${{ steps.validate.outputs.candidate_sha }}
      release_version: ${{ steps.version.outputs.release_version }}
    steps:
      - name: Validate accepted candidate on main
        id: validate
        env:
          GITHUB_TOKEN: ${{ github.token }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          CANDIDATE_SHA: ${{ inputs.candidate_sha }}
        run: |
          set -euo pipefail

          node <<'NODE'
          const fs = require("node:fs");

          const token = process.env.GITHUB_TOKEN;
          const repository = process.env.GITHUB_REPOSITORY;
          const candidateSha = process.env.CANDIDATE_SHA;
          const outputPath = process.env.GITHUB_OUTPUT;
          const apiVersion = "2022-11-28";

          async function request(pathname) {
            const response = await fetch(`https://api.github.com${pathname}`, {
              headers: {
                Accept: "application/vnd.github+json",
                Authorization: `Bearer ${token}`,
                "X-GitHub-Api-Version": apiVersion
              }
            });

            if (!response.ok) {
              const body = await response.text();
              throw new Error(`GitHub API request failed (${response.status}) ${pathname}\n${body}`);
            }

            return response.json();
          }

          function writeOutputs(runId) {
            fs.appendFileSync(outputPath, `cloud_deployment_pipeline_run_id=${runId}\n`);
            fs.appendFileSync(outputPath, `candidate_sha=${candidateSha}\n`);
          }

          (async () => {
            const data = await request(
              `/repos/${repository}/actions/workflows/cloud-deployment-pipeline.yml/runs?status=success&per_page=100`
            );

            const run = (data.workflow_runs || []).find(
              (entry) =>
                entry.head_sha === candidateSha &&
                entry.conclusion === "success" &&
                entry.head_branch === "main"
            );

            if (!run) {
              throw new Error(
                `No successful Cloud Deployment Pipeline run on main found for candidate ${candidateSha}`
              );
            }

            writeOutputs(String(run.id));
          })().catch((error) => {
            console.error(error instanceof Error ? error.message : String(error));
            process.exit(1);
          });
          NODE

      - name: Resolve release version
        id: version
        run: |
          set -euo pipefail
          tag="${{ inputs.release_tag }}"
          version="${tag#desktop-}"
          version="${version#v}"
          if [ -z "$version" ]; then
            echo "Unable to resolve release version from tag: $tag" >&2
            exit 1
          fi
          echo "release_version=$version" >> "$GITHUB_OUTPUT"

  build_macos:
    name: build-macos
    needs:
      - validate_candidate
    runs-on: macos-14
    environment: desktop-release
    steps:
      - name: Checkout candidate
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.validate_candidate.outputs.candidate_sha }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.30.1

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc
          cache: pnpm
          cache-dependency-path: pnpm-lock.yaml

      - name: Install dependencies
        env:
          npm_config_node_linker: hoisted
          npm_config_allow_build_scripts: esbuild,sharp,electron,fs-xattr,macos-alias,@bitdisaster/exe-icon-extractor
        run: pnpm install --frozen-lockfile

      - name: Decode signing assets
        id: signing_assets
        env:
          CERT_P12_BASE64: ${{ secrets.MACOS_SIGNING_CERT_P12_BASE64 }}
          APPLE_API_KEY_BASE64: ${{ secrets.APPLE_API_KEY_P8_BASE64 }}
        run: |
          set -euo pipefail

          cert_path="$RUNNER_TEMP/macos-signing-cert.p12"
          api_key_path="$RUNNER_TEMP/apple-api-key.p8"

          CERT_P12_BASE64="$CERT_P12_BASE64" APPLE_API_KEY_BASE64="$APPLE_API_KEY_BASE64" \
            CERT_PATH="$cert_path" API_KEY_PATH="$api_key_path" node <<'NODE'
          const fs = require("node:fs");

          const certPath = process.env.CERT_PATH;
          const apiKeyPath = process.env.API_KEY_PATH;

          fs.writeFileSync(certPath, Buffer.from(process.env.CERT_P12_BASE64 || "", "base64"));
          fs.writeFileSync(apiKeyPath, Buffer.from(process.env.APPLE_API_KEY_BASE64 || "", "base64"));
          NODE

          echo "cert_path=$cert_path" >> "$GITHUB_OUTPUT"
          echo "api_key_path=$api_key_path" >> "$GITHUB_OUTPUT"

      - name: Configure temporary keychain
        env:
          CERT_PATH: ${{ steps.signing_assets.outputs.cert_path }}
          CERT_PASSWORD: ${{ secrets.MACOS_SIGNING_CERT_PASSWORD }}
        run: |
          set -euo pipefail

          keychain="$RUNNER_TEMP/build.keychain-db"
          keychain_password="$(openssl rand -base64 24)"

          security create-keychain -p "$keychain_password" "$keychain"
          security set-keychain-settings -lut 21600 "$keychain"
          security unlock-keychain -p "$keychain_password" "$keychain"
          security list-keychains -d user -s "$keychain"
          security default-keychain -d user -s "$keychain"

          security import "$CERT_PATH" -k "$keychain" -P "$CERT_PASSWORD" -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple: -s -k "$keychain_password" "$keychain"

      - name: Build signed macOS DMG
        env:
          COMPASS_DESKTOP_START_URL: ${{ inputs.web_base_url }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER_ID: ${{ secrets.APPLE_API_ISSUER_ID }}
          APPLE_API_KEY_PATH: ${{ steps.signing_assets.outputs.api_key_path }}
        run: pnpm --filter @compass/desktop make:mac

      - name: Validate desktop runtime config contract
        run: pnpm --filter @compass/desktop smoke:artifact

      - name: Verify macOS signing and notarization
        run: |
          set -euo pipefail

          app_path="$(find apps/desktop/out -type d -name '*.app' | head -n 1)"
          dmg_path="$(find apps/desktop/out/make -type f -name '*.dmg' | head -n 1)"

          if [ -z "$app_path" ] || [ -z "$dmg_path" ]; then
            echo "Missing macOS app or DMG output." >&2
            exit 1
          fi

          codesign --verify --deep --strict --verbose=2 "$app_path"
          spctl --assess --type execute --verbose=4 "$app_path"
          xcrun stapler validate "$app_path"

      - name: Prepare macOS installer artifact
        id: collect
        run: |
          set -euo pipefail

          dmg_path="$(find apps/desktop/out/make -type f -name '*.dmg' | head -n 1)"
          version="${{ needs.validate_candidate.outputs.release_version }}"
          artifact_name="Compass-${version}-arm64.dmg"
          artifact_path="$RUNNER_TEMP/$artifact_name"

          cp "$dmg_path" "$artifact_path"
          echo "artifact_path=$artifact_path" >> "$GITHUB_OUTPUT"

      - name: Upload macOS installer artifact
        uses: actions/upload-artifact@v4
        with:
          name: desktop-macos-${{ needs.validate_candidate.outputs.candidate_sha }}
          path: ${{ steps.collect.outputs.artifact_path }}
          if-no-files-found: error

  build_windows:
    name: build-windows
    needs:
      - validate_candidate
    runs-on: windows-latest
    environment: desktop-release
    steps:
      - name: Checkout candidate
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.validate_candidate.outputs.candidate_sha }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.30.1

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc
          cache: pnpm
          cache-dependency-path: pnpm-lock.yaml

      - name: Install dependencies
        env:
          npm_config_node_linker: hoisted
          npm_config_allow_build_scripts: esbuild,sharp,electron,fs-xattr,macos-alias,@bitdisaster/exe-icon-extractor
        run: pnpm install --frozen-lockfile

      - name: Install WiX toolset
        run: choco install wixtoolset --yes

      - name: Build Windows MSI
        env:
          COMPASS_DESKTOP_START_URL: ${{ inputs.web_base_url }}
        run: pnpm --filter @compass/desktop make:win

      - name: Validate desktop runtime config contract
        run: pnpm --filter @compass/desktop smoke:artifact

      - name: Collect MSI path
        id: collect
        shell: pwsh
        run: |
          $msi = Get-ChildItem "apps/desktop/out/make" -Filter "*.msi" -Recurse | Select-Object -First 1
          if ($null -eq $msi) {
            throw "Missing MSI output in apps/desktop/out/make"
          }

          $version = "${{ needs.validate_candidate.outputs.release_version }}"
          $artifactName = "Compass-$version-x64.msi"
          $artifactPath = Join-Path $env:RUNNER_TEMP $artifactName
          Copy-Item $msi.FullName $artifactPath -Force

          "msi_path=$artifactPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Azure login for signing
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Sign MSI with Azure Artifact Signing
        uses: azure/artifact-signing-action@v1
        with:
          endpoint: ${{ vars.TRUSTED_SIGNING_ENDPOINT }}
          signing-account-name: ${{ vars.TRUSTED_SIGNING_ACCOUNT_NAME }}
          certificate-profile-name: ${{ vars.TRUSTED_SIGNING_PROFILE_NAME }}
          files: ${{ steps.collect.outputs.msi_path }}
          file-digest: SHA256
          timestamp-rfc3161: http://timestamp.acs.microsoft.com
          timestamp-digest: SHA256

      - name: Verify Authenticode signature
        shell: pwsh
        run: |
          $signature = Get-AuthenticodeSignature "${{ steps.collect.outputs.msi_path }}"
          if ($signature.Status -ne "Valid") {
            throw "Invalid Windows signature status: $($signature.Status)"
          }

      - name: Upload Windows installer artifact
        uses: actions/upload-artifact@v4
        with:
          name: desktop-windows-${{ needs.validate_candidate.outputs.candidate_sha }}
          path: ${{ steps.collect.outputs.msi_path }}
          if-no-files-found: error

  publish_release:
    name: publish-release
    needs:
      - validate_candidate
      - build_macos
      - build_windows
    if: ${{ needs.validate_candidate.result == 'success' && needs.build_macos.result == 'success' && needs.build_windows.result == 'success' }}
    runs-on: ubuntu-latest
    steps:
      - name: Download macOS installer artifact
        uses: actions/download-artifact@v4
        with:
          name: desktop-macos-${{ needs.validate_candidate.outputs.candidate_sha }}
          path: .artifacts/desktop/${{ needs.validate_candidate.outputs.candidate_sha }}/installers

      - name: Download Windows installer artifact
        uses: actions/download-artifact@v4
        with:
          name: desktop-windows-${{ needs.validate_candidate.outputs.candidate_sha }}
          path: .artifacts/desktop/${{ needs.validate_candidate.outputs.candidate_sha }}/installers

      - name: Generate checksums
        working-directory: .artifacts/desktop/${{ needs.validate_candidate.outputs.candidate_sha }}/installers
        run: |
          set -euo pipefail
          shopt -s nullglob

          files=( *.dmg *.msi )
          if [ "${#files[@]}" -eq 0 ]; then
            echo "No installer artifacts found to checksum." >&2
            exit 1
          fi

          sha256sum "${files[@]}" > SHA256SUMS.txt

      - name: Create release manifest
        run: |
          set -euo pipefail

          artifact_dir=".artifacts/desktop/${{ needs.validate_candidate.outputs.candidate_sha }}"
          installers_dir="$artifact_dir/installers"
          manifest_path="$artifact_dir/release-manifest.json"

          node <<'NODE'
          const fs = require("node:fs");
          const path = require("node:path");
          const crypto = require("node:crypto");

          const artifactDir = process.env.ARTIFACT_DIR;
          const installersDir = process.env.INSTALLERS_DIR;
          const manifestPath = process.env.MANIFEST_PATH;
          const releaseTag = process.env.RELEASE_TAG;
          const candidateSha = process.env.CANDIDATE_SHA;
          const cloudDeploymentPipelineRunId = process.env.CLOUD_DEPLOYMENT_PIPELINE_RUN_ID;

          const files = fs
            .readdirSync(installersDir)
            .filter((name) => [".dmg", ".msi", ".txt"].includes(path.extname(name)))
            .sort();

          const artifacts = files.map((name) => {
            const filePath = path.join(installersDir, name);
            const content = fs.readFileSync(filePath);
            return {
              fileName: name,
              bytes: content.length,
              sha256: crypto.createHash("sha256").update(content).digest("hex")
            };
          });

          const payload = {
            schemaVersion: "1",
            generatedAt: new Date().toISOString(),
            candidateSha,
            cloudDeploymentPipelineRunId,
            releaseTag,
            artifacts
          };

          fs.mkdirSync(artifactDir, { recursive: true });
          fs.writeFileSync(manifestPath, `${JSON.stringify(payload, null, 2)}\n`);
          NODE
        env:
          ARTIFACT_DIR: .artifacts/desktop/${{ needs.validate_candidate.outputs.candidate_sha }}
          INSTALLERS_DIR: .artifacts/desktop/${{ needs.validate_candidate.outputs.candidate_sha }}/installers
          MANIFEST_PATH: .artifacts/desktop/${{ needs.validate_candidate.outputs.candidate_sha }}/release-manifest.json
          RELEASE_TAG: ${{ inputs.release_tag }}
          CANDIDATE_SHA: ${{ needs.validate_candidate.outputs.candidate_sha }}
          CLOUD_DEPLOYMENT_PIPELINE_RUN_ID: ${{ needs.validate_candidate.outputs.cloud_deployment_pipeline_run_id }}

      - name: Publish GitHub release assets
        env:
          GH_TOKEN: ${{ github.token }}
          RELEASE_TAG: ${{ inputs.release_tag }}
          DRAFT: ${{ inputs.draft }}
          CANDIDATE_SHA: ${{ needs.validate_candidate.outputs.candidate_sha }}
        run: |
          set -euo pipefail
          shopt -s nullglob

          installers_dir=".artifacts/desktop/$CANDIDATE_SHA/installers"
          cd "$installers_dir"

          dmg_files=( *.dmg )
          msi_files=( *.msi )
          if [ "${#dmg_files[@]}" -eq 0 ]; then
            echo "Expected at least one DMG in release installers directory." >&2
            exit 1
          fi
          if [ "${#msi_files[@]}" -eq 0 ]; then
            echo "Expected at least one MSI in release installers directory." >&2
            exit 1
          fi

          dmg_file="${dmg_files[0]}"
          msi_file="${msi_files[0]}"
          sums_file="SHA256SUMS.txt"
          assets=( "$dmg_file" "$msi_file" "$sums_file" )
          notes="Desktop installers for candidate ${CANDIDATE_SHA}\n\nSigning mode: signed (macOS signed/notarized, Windows signed)."

          if gh release view "$RELEASE_TAG" >/dev/null 2>&1; then
            gh release upload "$RELEASE_TAG" "${assets[@]}" --clobber
            gh release edit "$RELEASE_TAG" --title "$RELEASE_TAG" --notes "$notes"
          else
            if [ "$DRAFT" = "true" ]; then
              gh release create "$RELEASE_TAG" "${assets[@]}" --title "$RELEASE_TAG" --notes "$notes" --draft
            else
              gh release create "$RELEASE_TAG" "${assets[@]}" --title "$RELEASE_TAG" --notes "$notes"
            fi
          fi

      - name: Upload desktop release manifest artifact
        uses: actions/upload-artifact@v4
        with:
          name: desktop-release-${{ needs.validate_candidate.outputs.candidate_sha }}
          path: .artifacts/desktop/${{ needs.validate_candidate.outputs.candidate_sha }}/release-manifest.json
          if-no-files-found: error
